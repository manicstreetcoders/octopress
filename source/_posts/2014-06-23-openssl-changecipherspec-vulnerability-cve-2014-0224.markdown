---
layout: post
title: "OpenSSL: ChangeCipherSpec Vulnerability (CVE-2014-0224)"
date: 2014-06-23 09:23:27 +0900
comments: true
categories: 
---

#### Original Post

Original post 는 다음과 같다. 발견자는 Masashi Kikuchi 씨.

[How I discovered CCS Injection Vulnerability (CVE-2014-0224)](http://ccsinjection.lepidum.co.jp/blog/2014-06-05/CCS-Injection-en/index.html)

ChangeCipherSpec 이라는 메시지는 정해진 스텝에서만 주고받아야 하는데, 서버가 막 받아주는 것이 문제.

ChangeCipherSepc 은 무얼까? 세션키에 기반한 symmetric encryption 모드로 전환하자는 신호. Pre-master secret 을 교환하고나서 이제 session key 를 계산해서 symmetric encryption 모드로 가자! 라는 신호. 기술적으로는 1 바이트 메시지. 페이로드는 0x01.

    In a correct handshake, the client and the server exchange messages 
    in the order as depicted in this figure. 
    (See RFC5246 The Transport Layer Security (TLS) Protocol Version 1.2 §7.3)。

    ChangeCipherSpec MUST be sent at these positions in the handshake. 
    OpenSSL sends CCS in exact timing itself. 
    However, it accepts CCS at other timings when receiving. 
    Attackers can exploit this behavior so that they can decrypt and/or 
    modify data in the communication channel.

Full handshake 의 예를 들면, ClientHello, ServerHello, ClientKeyExchange 가 되고, ChangeCipherSpec 이 들어가야한다.

발견자에 따르면, TLS IETF draft 에 있는 다음 문장이 취약점을 만든 이유라고.

    Note:          To help avoid pipeline stalls, ChangeCipherSpec is
                   an independent SSL Protocol content type, and is not
                   actually an SSL handshake message.

handshake message 타입이 아니라 독립적인 프로토콜 타입으로 되어있는데, 그 이유는

[Why is change cipher spec an independent protocol content type and not part of Handshake Messages?](http://security.stackexchange.com/questions/24755/why-is-change-cipher-spec-an-independent-protocol-content-type-and-not-part-of-h)


#### PoC

[Metasploit openssl_ccs.rb module](https://github.com/rapid7/metasploit-framework/blob/master/modules/auxiliary/scanner/ssl/openssl_ccs.rb) 을 보면,

`Client_Hello` 를 보내고, `Server_Hello` 를 받아준 다음에 바로 CCS (0x01) 을 보낸다. 만약 Alert 이 뜨지 않으면 vulnerable 하다고 본다.

    def ccs_injection
      connect_result = establish_connect
      return if connect_result.nil?
  
      vprint_status("#{peer} - Sending CCS...")
      sock.put(ccs)
      alert = sock.get_once(-1, response_timeout)
      if alert.blank?
        print_good("#{peer} - No alert after invalid CSS message, probably vulnerable")
        report
      elsif alert.unpack("C").first == ALERT_RECORD_TYPE
        vprint_error("#{peer} - Alert record as response to the invalid CCS Message, probably not vulnerable")
      elsif alert
        vprint_warning("#{peer} - Unexpected response.")
      end
    end
  
    def establish_connect
      connect
  
      vprint_status("#{peer} - Sending Client Hello...")
      sock.put(client_hello)
      server_hello = sock.get(response_timeout)
  
      unless server_hello
        vprint_error("#{peer} - No Server Hello after #{response_timeout} seconds...")
        disconnect
        return nil
      end
  
      unless server_hello.unpack("C").first == HANDSHAKE_RECORD_TYPE
        vprint_error("#{peer} - Server Hello Not Found")
        return nil
      end
  
      true
    end


#### Code

실제 코드를 분석한 블로그를 보면

[Early ChangeCipherSpec Attack (05 Jun 2014)](https://www.imperialviolet.org/2014/06/05/earlyccs.html)

ServerHello 이후에 CCS 가 inject 되면, 취약한 키가 생성되는게 핵심. 
추후에 CCS 가 더 inject 되더라도 한번 생성된 키는 고정되버리는 것도 문제.

    If a ChangeCipherSpec message is injected into the connection after the ServerHello, 
    but before the master secret has been generated, 
    then ssl3_do_change_cipher_spec will generate the keys (2) and 
    the expected Finished hash (3) for the handshake with an empty master secret. 
    This means that both are based only on public information. 
    Additionally, the keys will be latched because of the check at (1) - 
    further ChangeCipherSpec messages will regenerate the expected Finished hash, but not the keys.

코드를 보면,

    int ssl3_do_change_cipher_spec(SSL *s)
            {
            int i;
            const char *sender;
            int slen;

            if (s->state & SSL_ST_ACCEPT)
                    i=SSL3_CHANGE_CIPHER_SERVER_READ;
            else
                    i=SSL3_CHANGE_CIPHER_CLIENT_READ;

            if (s->s3->tmp.key_block == NULL) <---- 1
                    {
                    if (s->session == NULL)
                            {
                            /* might happen if dtls1_read_bytes() calls this */
                            SSLerr(SSL_F_SSL3_DO_CHANGE_CIPHER_SPEC,SSL_R_CCS_RECEIVED_EARLY);
                            return (0);
                            }

                    s->session->cipher=s->s3->tmp.new_cipher;
                    if (!s->method->ssl3_enc->setup_key_block(s)) return(0); <---- 2
                    }

            if (!s->method->ssl3_enc->change_cipher_state(s,i))
                    return(0);

            /* we have to record the message digest at
             * this point so we can get it before we read
             * the finished message */
            if (s->state & SSL_ST_CONNECT)
                    {
                    sender=s->method->ssl3_enc->server_finished_label;
                    slen=s->method->ssl3_enc->server_finished_label_len;
                    }
            else
                    {
                    sender=s->method->ssl3_enc->client_finished_label;
                    slen=s->method->ssl3_enc->client_finished_label_len;
                    }

            i = s->method->ssl3_enc->final_finish_mac(s,
                    sender,slen,s->s3->tmp.peer_finish_md); <---- 3
            if (i == 0)
                    {
                    SSLerr(SSL_F_SSL3_DO_CHANGE_CIPHER_SPEC, ERR_R_INTERNAL_ERROR);
                    return 0;
                    }
            s->s3->tmp.peer_finish_md_len = i;

            return(1);
            }


#### MitM

이 버그를 가지고 Man-in-the-Middle 을 하는 시나리오를 생각해보자.
