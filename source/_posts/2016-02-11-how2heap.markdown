---
layout: post
title: "how2heap"
date: 2016-02-11 17:45:34 +0900
comments: true
categories: 
---

shellphish team 에서 github 에 공개한 [Educational Heap Exploitation](https://github.com/shellphish/how2heap) 을 정리한다.

* [Understanding glibc malloc](https://sploitfun.wordpress.com/2015/02/10/understanding-glibc-malloc/)

#### first_fit.c

[first_fit.c](https://github.com/shellphish/how2heap/blob/master/first_fit.c)

malloc() allocator 의 behavior 때문에 생기는 use after free 상황을 설명하기 위한 예제.

malloc() 후에, free() 하고 다시 malloc() 을 했더니, 두 개의 포인터가 동일한 위치를 가리킨다. 편의상 포인터를 A,B 라고 하자. A 는 free 된 포인터, B 는 legitimate 한 포인터. B 를 통해 메모리 내용을 조작한다음에 A 가 사용되면 A object 의 context 에서 메모리내용이 해석되기때문에, 의도치않은 코드가 수행될 수 있다.

#### house_of_spirit.c

[house of spirit](https://github.com/shellphish/how2heap/blob/master/house_of_spirit.c)

House of spirit 공격을 설명하기 위한 예제.

House of spirit 공격을 요약하면.

* House of spirit 공격은 다른 heap 공격과는 달리, 메타데이터를 overwrite 하는 것이 목적이 아니다.
* malloc() 에서 return 되는 address 를 컨트롤 할 수 있다.
* `p = malloc(...); memcpy(p, user_supplied_data, 128);` 에서 p 의 값을 컨트롤 할 수 있다면, code execution 은 어렵지 않다. 임의의 주소에 임의의 값을 쓸 수 있는 primitive 를 얻게 되는 셈이니.
* p 를 컨트롤하는 방법은, 가짜 chunk 주소를 fastbin 에 밀어넣어서, 다음 malloc 때 저 chunk 가 리턴되게 하는 것.
* 가짜 chunk 주소를 fastbin 에 밀어넣는 방법은, free() 를 통해서.
* 정상적으로 malloc() 을 통해서 받아온 pointer `p` 를 free() 의 인자로 주는 것이 아니라, 공격하고 싶은 메모리 주소를 fastbin 에 밀어넣기 위한 조작된 데이터를 free() 의 인자로 넘긴다.
