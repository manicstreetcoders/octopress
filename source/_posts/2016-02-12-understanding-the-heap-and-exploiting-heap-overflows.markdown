---
layout: post
title: "Understanding the Heap &amp; Exploiting Heap Overflows"
date: 2016-02-12 16:13:07 +0900
comments: true
categories: 
---

Mathy Vanhoef blog 의 [Understanding the Heap & Exploiting Heap Overflows](http://www.mathyvanhoef.com/2013/02/understanding-heap-exploiting-heap.html) 를 정리한다.

먼저 취약한 예제.

```
#include <string.h>
#include <stdlib.h>
#include <stdio.h>

int main(int argc, char *argv[])
{
	char *buf1 = malloc(128);
	char *buf2 = malloc(256);

	printf("addr buf1: %p\n", buf1);
	printf("addr buf2: %p\n", buf2);

	read(fileno(stdin), buf1, 200);

	free(buf2);
	free(buf1);
}
```

#### Basic Heap and Chunk Layout

```
struct malloc_chunk {
	INTERNAL_SIZE_T		prev_size;
	INTERNAL_SIZE_T		size;
	
	struct malloc_chunk* fd;
	struct malloc_chunk* bk;

	struct malloc_chunk* fd_nextsize;
	struct malloc_chunk* bk_nextsize;
}
```

#### Interpretation of the Chunk Structure

* Allocated chunk 에서 사용되는 필드는 size 뿐이다. 
* 그리고, `malloc()` 으로 돌아오는 포인터는 `fd` 랑 일치한다. 
* `fd`, `bk` 를 이용해서 free 된 chunk 를 doubly linked list 로 관리한다.
* size 의 하위 3 bit 는 사용되지 않는다. (align 되기때문에 항상 000 이 된다)
* 그래서, size 의 사용되지 않는 하위 비트들을 flag 로 사용한다.
* size 의 LSB 는 previous chunk 가 alloc 인지 아닌지 flag 로 사용된다.
* current chunk 가 사용되고 있는지 아닌지 아는 방법은, next chunk 의 size 필드의 LSB 를 보는 것이다. 즉 `cur_chunk + size + sizeof(INTERNAL_SIZE_T)` 로 next chunk 로 가서, `size & 0x1` 로 체크하는 것이다.

#### Managing Free Chunks
