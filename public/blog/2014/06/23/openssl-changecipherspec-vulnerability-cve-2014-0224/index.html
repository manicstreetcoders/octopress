
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>OpenSSL: ChangeCipherSpec Vulnerability (CVE-2014-0224) - KC's blog</title>
  <meta name="author" content="KC">

  
  <meta name="description" content="Original Post Original post 는 다음과 같다. 발견자는 Masashi Kikuchi 씨. How I discovered CCS Injection Vulnerability (CVE-2014-0224) ChangeCipherSpec 이라는 메시지는 &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://zomo.heroku.com/blog/2014/06/23/openssl-changecipherspec-vulnerability-cve-2014-0224/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="KC's blog" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="/javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">KC's blog</a></h1>
  
    <h2>A blogging framework for hackers.</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="sitesearch" value="zomo.heroku.com">
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div>
<article class="hentry" role="article">
  
  <header>
    
      <h1 class="entry-title">OpenSSL: ChangeCipherSpec Vulnerability (CVE-2014-0224)</h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2014-06-23T09:23:27+09:00'><span class='date'><span class='date-month'>Jun</span> <span class='date-day'>23</span><span class='date-suffix'>rd</span>, <span class='date-year'>2014</span></span> <span class='time'>9:23 am</span></time>
        
      </p>
    
  </header>


<div class="entry-content"><h4>Original Post</h4>

<p>Original post 는 다음과 같다. 발견자는 Masashi Kikuchi 씨.</p>

<p><a href="http://ccsinjection.lepidum.co.jp/blog/2014-06-05/CCS-Injection-en/index.html">How I discovered CCS Injection Vulnerability (CVE-2014-0224)</a></p>

<p>ChangeCipherSpec 이라는 메시지는 정해진 스텝에서만 주고받아야 하는데, 서버가 막 받아주는 것이 문제.</p>

<p>ChangeCipherSepc 은 무얼까? 세션키에 기반한 symmetric encryption 모드로 전환하자는 신호. Pre-master secret 을 교환하고나서 이제 session key 를 계산해서 symmetric encryption 모드로 가자! 라는 신호. 기술적으로는 1 바이트 메시지. 페이로드는 0x01.</p>

<pre><code>In a correct handshake, the client and the server exchange messages 
in the order as depicted in this figure. 
(See RFC5246 The Transport Layer Security (TLS) Protocol Version 1.2 §7.3)。

ChangeCipherSpec MUST be sent at these positions in the handshake. 
OpenSSL sends CCS in exact timing itself. 
However, it accepts CCS at other timings when receiving. 
Attackers can exploit this behavior so that they can decrypt and/or 
modify data in the communication channel.
</code></pre>

<p>Full handshake 의 예를 들면, ClientHello, ServerHello, ClientKeyExchange 가 되고, ChangeCipherSpec 이 들어가야한다.</p>

<p>발견자에 따르면, TLS IETF draft 에 있는 다음 문장이 취약점을 만든 이유라고.</p>

<pre><code>Note:          To help avoid pipeline stalls, ChangeCipherSpec is
               an independent SSL Protocol content type, and is not
               actually an SSL handshake message.
</code></pre>

<p>handshake message 타입이 아니라 독립적인 프로토콜 타입으로 되어있는데, 그 이유는</p>

<p><a href="http://security.stackexchange.com/questions/24755/why-is-change-cipher-spec-an-independent-protocol-content-type-and-not-part-of-h">Why is change cipher spec an independent protocol content type and not part of Handshake Messages?</a></p>

<h4>PoC</h4>

<p><a href="https://github.com/rapid7/metasploit-framework/blob/master/modules/auxiliary/scanner/ssl/openssl_ccs.rb">Metasploit openssl_ccs.rb module</a> 을 보면,</p>

<p><code>Client_Hello</code> 를 보내고, <code>Server_Hello</code> 를 받아준 다음에 바로 CCS (0x01) 을 보낸다. 만약 Alert 이 뜨지 않으면 vulnerable 하다고 본다.</p>

<pre><code>def ccs_injection
  connect_result = establish_connect
  return if connect_result.nil?

  vprint_status("#{peer} - Sending CCS...")
  sock.put(ccs)
  alert = sock.get_once(-1, response_timeout)
  if alert.blank?
    print_good("#{peer} - No alert after invalid CSS message, probably vulnerable")
    report
  elsif alert.unpack("C").first == ALERT_RECORD_TYPE
    vprint_error("#{peer} - Alert record as response to the invalid CCS Message, probably not vulnerable")
  elsif alert
    vprint_warning("#{peer} - Unexpected response.")
  end
end

def establish_connect
  connect

  vprint_status("#{peer} - Sending Client Hello...")
  sock.put(client_hello)
  server_hello = sock.get(response_timeout)

  unless server_hello
    vprint_error("#{peer} - No Server Hello after #{response_timeout} seconds...")
    disconnect
    return nil
  end

  unless server_hello.unpack("C").first == HANDSHAKE_RECORD_TYPE
    vprint_error("#{peer} - Server Hello Not Found")
    return nil
  end

  true
end
</code></pre>

<h4>Code</h4>

<p>실제 코드를 분석한 블로그를 보면</p>

<p><a href="https://www.imperialviolet.org/2014/06/05/earlyccs.html">Early ChangeCipherSpec Attack (05 Jun 2014)</a></p>

<p>ServerHello 이후에 CCS 가 inject 되면, 취약한 키가 생성되는게 핵심.
추후에 CCS 가 더 inject 되더라도 한번 생성된 키는 고정되버리는 것도 문제.</p>

<pre><code>If a ChangeCipherSpec message is injected into the connection after the ServerHello, 
but before the master secret has been generated, 
then ssl3_do_change_cipher_spec will generate the keys (2) and 
the expected Finished hash (3) for the handshake with an empty master secret. 
This means that both are based only on public information. 
Additionally, the keys will be latched because of the check at (1) - 
further ChangeCipherSpec messages will regenerate the expected Finished hash, but not the keys.
</code></pre>

<p>코드를 보면,</p>

<pre><code>int ssl3_do_change_cipher_spec(SSL *s)
        {
        int i;
        const char *sender;
        int slen;

        if (s-&gt;state &amp; SSL_ST_ACCEPT)
                i=SSL3_CHANGE_CIPHER_SERVER_READ;
        else
                i=SSL3_CHANGE_CIPHER_CLIENT_READ;

        if (s-&gt;s3-&gt;tmp.key_block == NULL) &lt;---- 1
                {
                if (s-&gt;session == NULL)
                        {
                        /* might happen if dtls1_read_bytes() calls this */
                        SSLerr(SSL_F_SSL3_DO_CHANGE_CIPHER_SPEC,SSL_R_CCS_RECEIVED_EARLY);
                        return (0);
                        }

                s-&gt;session-&gt;cipher=s-&gt;s3-&gt;tmp.new_cipher;
                if (!s-&gt;method-&gt;ssl3_enc-&gt;setup_key_block(s)) return(0); &lt;---- 2
                }

        if (!s-&gt;method-&gt;ssl3_enc-&gt;change_cipher_state(s,i))
                return(0);

        /* we have to record the message digest at
         * this point so we can get it before we read
         * the finished message */
        if (s-&gt;state &amp; SSL_ST_CONNECT)
                {
                sender=s-&gt;method-&gt;ssl3_enc-&gt;server_finished_label;
                slen=s-&gt;method-&gt;ssl3_enc-&gt;server_finished_label_len;
                }
        else
                {
                sender=s-&gt;method-&gt;ssl3_enc-&gt;client_finished_label;
                slen=s-&gt;method-&gt;ssl3_enc-&gt;client_finished_label_len;
                }

        i = s-&gt;method-&gt;ssl3_enc-&gt;final_finish_mac(s,
                sender,slen,s-&gt;s3-&gt;tmp.peer_finish_md); &lt;---- 3
        if (i == 0)
                {
                SSLerr(SSL_F_SSL3_DO_CHANGE_CIPHER_SPEC, ERR_R_INTERNAL_ERROR);
                return 0;
                }
        s-&gt;s3-&gt;tmp.peer_finish_md_len = i;

        return(1);
        }
</code></pre>

<h4>MitM</h4>

<p>이 버그를 가지고 Man-in-the-Middle 을 하는 시나리오를 생각해보자.</p>
</div>


  <footer>
    <p class="meta">
      
  

<span class="byline author vcard">Posted by <span class="fn">KC</span></span>

      




<time class='entry-date' datetime='2014-06-23T09:23:27+09:00'><span class='date'><span class='date-month'>Jun</span> <span class='date-day'>23</span><span class='date-suffix'>rd</span>, <span class='date-year'>2014</span></span> <span class='time'>9:23 am</span></time>
      


    </p>
    
      <div class="sharing">
  
  <a href="//twitter.com/share" class="twitter-share-button" data-url="http://zomo.heroku.com/blog/2014/06/23/openssl-changecipherspec-vulnerability-cve-2014-0224/" data-via="" data-counturl="http://zomo.heroku.com/blog/2014/06/23/openssl-changecipherspec-vulnerability-cve-2014-0224/" >Tweet</a>
  
  
  
</div>

    
    <p class="meta">
      
        <a class="basic-alignment left" href="/blog/2014/06/20/ssl-strip/" title="Previous Post: SSL Strip">&laquo; SSL Strip</a>
      
      
        <a class="basic-alignment right" href="/blog/2014/06/23/beast-attack/" title="Next Post: BEAST Attack">BEAST Attack &raquo;</a>
      
    </p>
  </footer>
</article>

</div>

<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2016/01/11/cve-2013-2094-perf-swevent-enabled-revisited/">CVE-2013-2094: Perf_swevent_enabled Revisited</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/01/11/bsides-vienna-2015-writing-your-first-windows-exploit-in-less-than-one-hour/">BSides Vienna 2015: Writing Your First Windows Exploit in Less Than One Hour</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/01/11/sock-sendpage/">Sock_sendpage</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/12/23/on-the-juniper-backdoor/">On the Juniper Backdoor</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/12/07/trustnone/">TRUSTNONE</a>
      </li>
    
  </ul>
</section>





  
</aside>


    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2016 - KC -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = '//platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
